<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yitao&#39;s Blog</title>
  
  
  <link href="https://zjuytw.github.io/atom.xml" rel="self"/>
  
  <link href="https://zjuytw.github.io/"/>
  <updated>2022-01-30T09:10:32.014Z</updated>
  <id>https://zjuytw.github.io/</id>
  
  <author>
    <name>Wang Yitao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MIT6.S081 Lecture14 Ext3fs crash recovery</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec13--%20Ex3%20Recovery/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec13--%20Ex3%20Recovery/</id>
    <published>2022-01-30T09:02:37.100Z</published>
    <updated>2022-01-30T09:10:32.014Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux-ext3fs-crash-recovery-system"><a href="#Linux-ext3fs-crash-recovery-system" class="headerlink" title="Linux ext3fs crash recovery system"></a>Linux ext3fs crash recovery system</h3><h4 id="xv6-Design-Defects"><a href="#xv6-Design-Defects" class="headerlink" title="xv6 Design Defects"></a>xv6 Design Defects</h4><ul><li>Every block needs to be written twice(one for log and another for fs)</li><li>Syscall needs wait for committing</li><li>disk I/O is synchronized</li></ul><h4 id="ext3-Journal-Design"><a href="#ext3-Journal-Design" class="headerlink" title="ext3 Journal Design"></a>ext3 Journal Design</h4><p>ext3 could track on multiple transactions’ status at one time to get more parallelism. Similar to xv6, ext3 has <strong>write-back block cache</strong> and maintains each transaction a <strong>transaction info</strong>, includes </p><ul><li>Every transaction has a sequence number</li><li>Revised block number by this tnx</li><li>handles</li></ul><p>On disk <strong>circular log</strong> has:</p><ul><li><strong>log super block</strong>: recording <em>offset</em> of transaction with the lowest sequence number and its <em>sequence number</em></li><li><strong>descriptor block</strong>: Every transaction’s head block, recording seq# and home block#, and magic#</li><li><strong>data block</strong></li><li><strong>commit block</strong>: Every transaction’s tail block, has magic#.</li></ul><p>When log is full or elapse times out, ext3 will write <em>log block</em> into <em>home disk</em> starts at the smallest seq# transaction.</p><h4 id="Commit-Transaction"><a href="#Commit-Transaction" class="headerlink" title="Commit Transaction"></a>Commit Transaction</h4><ul><li>Temporarily block new syscalls</li><li>Wait for <em>outstanding syscall</em> ends, because one transaction has a rather long time window, we need to wait for all syscalls in the window to finish.</li><li>start a new transaction, unblock syscalls</li><li>write block numbers into <em>descriptor block</em></li><li>write corresponding <em>data block</em></li><li>write <em>commit block</em>, after it is written, commit finishes.</li><li>write to <em>home location</em></li><li>release  <em>log block</em></li></ul><h4 id="Recovery-Steps"><a href="#Recovery-Steps" class="headerlink" title="Recovery Steps"></a>Recovery Steps</h4><ul><li>After rebooting, system first looks at super block and seeks for smallest valid seq#’s transaction</li><li>Find the log’s tail, if it missed a commit flag( by magic #) or encounter a false seq #, we just skip this.</li><li>Write all valid commit log</li></ul><h4 id="Performance-Analysis"><a href="#Performance-Analysis" class="headerlink" title="Performance Analysis"></a>Performance Analysis</h4><ul><li> Asynchronous disk update</li><li>syscall don’t have to wait for disk I/O, instead it just modify buffer cache and different syscall’s log could be <code>absorbed</code> for group commit</li><li>But we need to be careful with this <strong>may not flushed</strong> syscall. <strong>Could use fsync(fd) to force flush</strong></li><li>Batching<ul><li>Group Commit</li><li>Amortize block seeking time</li><li>write absorption</li><li>disk scheduling: Write block in a ordered sequence instead of random I/O</li></ul></li><li>Concurrency<ul><li>Log enables multiple transaction, each transaction may in different stage:<ul><li>Open : Able to accept new syscall’s write</li><li>Committing</li><li>Committed</li><li>Old: waiting to be freed </li></ul></li></ul></li></ul><h4 id="Collision-Handling"><a href="#Collision-Handling" class="headerlink" title="Collision Handling"></a>Collision Handling</h4><p>Assume a scenario that when <strong>committing</strong> a transaction, because ext3 doesn’t block syscall, if a new transaction needs to do modification basing on previous transaction’s blocks. And we need to make sure current buffer cache won’t be modified while committing, so we could grep a buffer cache’s copy to the new transaction. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Linux-ext3fs-crash-recovery-system&quot;&gt;&lt;a href=&quot;#Linux-ext3fs-crash-recovery-system&quot; class=&quot;headerlink&quot; title=&quot;Linux ext3fs crash recov</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture13 Crash Recovery</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec12--%20Crash%20Recovery/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec12--%20Crash%20Recovery/</id>
    <published>2022-01-30T09:02:37.098Z</published>
    <updated>2022-01-30T08:58:33.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Crash-Recovery"><a href="#Crash-Recovery" class="headerlink" title="Crash Recovery"></a>Crash Recovery</h3><h4 id="Logging"><a href="#Logging" class="headerlink" title="Logging"></a>Logging</h4><p>To achieve a atomic transaction, xv6 use logging to avoid data inconsistence if crash happens while writing. XV6’s syscall won’t write through the inode’s block, instead, it writes ops into log, after the transaction is committed, then xv6 itself writes the log into disk.</p><h4 id="Log-design"><a href="#Log-design" class="headerlink" title="Log design"></a>Log design</h4><p>Disk has a continuous space for logging storage, and consists of a <code>header block</code> foe meta info and a bunch of <code>block copy</code>.  <code>header block</code> records block index and block number. In xv6, just one transaction is doing at one time.</p><p><code>group commit</code>, xv6 could wrap many syscall()s and pack them into one transaction to increase parallelism. Also, because of limited <code>log block</code>,  XV6 will split one large write into many little transactions to fit log.</p><ul><li><strong>Write Ahead</strong>: Only modified blocks are written into log blocks then system starts to write into home location.</li><li><strong>Freeing</strong>:  Till all log blocks written into home location and header block is wiped, then we free log block.</li></ul><h4 id="Code-Analysis"><a href="#Code-Analysis" class="headerlink" title="Code Analysis:"></a>Code Analysis:</h4><ul><li><p>Start with begin_op(), to tell OS I’m gonna start a safe atomic transaction.</p><p><code>log.outstanding</code> is the number of syscall that queues at the current transaction.</p><p><code>MAXBLOCKS</code> is the threshold one syscall could use.</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">begin_op</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">log</span>.committing)&#123;</span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">log</span>.lh.n + (<span class="built_in">log</span>.outstanding+<span class="number">1</span>)*MAXOPBLOCKS &gt; LOGSIZE)&#123;</span><br><span class="line">      <span class="comment">// this op might exhaust log space; wait for commit.</span></span><br><span class="line">      sleep(&amp;<span class="built_in">log</span>, &amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">log</span>.outstanding += <span class="number">1</span>;</span><br><span class="line">      release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>log_write(struct buf* b)</code> . Write the modified block index in the header.  This function will <em>reserve</em> a slot for this buf by <em>increasing header-&gt;n</em> , then <code>pin</code> this buf in the buffer cache (to meet the requirement of <em>Write Ahead Rule</em>).</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Caller has modified b-&gt;data and is done with the buffer.</span></span><br><span class="line"><span class="comment">// Record the block number and pin in the cache by increasing refcnt.</span></span><br><span class="line"><span class="comment">// commit()/write_log() will do the disk write.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// log_write() replaces bwrite(); a typical use is:</span></span><br><span class="line"><span class="comment">//   bp = bread(...)</span></span><br><span class="line"><span class="comment">//   modify bp-&gt;data[]</span></span><br><span class="line"><span class="comment">//   log_write(bp)</span></span><br><span class="line"><span class="comment">//   brelse(bp)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">log_write</span><span class="params">(struct buf *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt;= LOGSIZE || <span class="built_in">log</span>.lh.n &gt;= <span class="built_in">log</span>.size - <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;too big a transaction&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.outstanding &lt; <span class="number">1</span>)</span><br><span class="line">    panic(<span class="string">&quot;log_write outside of trans&quot;</span>);</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">log</span>.lh.block[i] == b-&gt;blockno)   <span class="comment">// log absorbtion</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">log</span>.lh.block[i] = b-&gt;blockno;</span><br><span class="line">  <span class="keyword">if</span> (i == <span class="built_in">log</span>.lh.n) &#123;  <span class="comment">// Add new block to log?</span></span><br><span class="line">    bpin(b);</span><br><span class="line">    <span class="built_in">log</span>.lh.n++;</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>end_op()</code>,  decrease outstanding, and do <code>commit</code> if outstanding becomes zero.</p><p>Note <code>wakeup(&amp;log)</code> is to wake up other process blocked on channel <code>log</code>. Because in end_up(), current process don’t need such reserved space as it claimed at begin_op()  </p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// called at the end of each FS system call.</span></span><br><span class="line"><span class="comment">// commits if this was the last outstanding operation.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">end_op</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> do_commit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  <span class="built_in">log</span>.outstanding -= <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.committing)</span><br><span class="line">    panic(<span class="string">&quot;log.committing&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">log</span>.outstanding == <span class="number">0</span>)&#123;</span><br><span class="line">    do_commit = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// begin_op() may be waiting for log space,</span></span><br><span class="line">    <span class="comment">// and decrementing log.outstanding has decreased</span></span><br><span class="line">    <span class="comment">// the amount of reserved space.</span></span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(do_commit)&#123;</span><br><span class="line">    <span class="comment">// call commit w/o holding locks, since not allowed</span></span><br><span class="line">    <span class="comment">// to sleep with locks.</span></span><br><span class="line">    commit();</span><br><span class="line">    acquire(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">    <span class="built_in">log</span>.committing = <span class="number">0</span>;</span><br><span class="line">    wakeup(&amp;<span class="built_in">log</span>);</span><br><span class="line">    release(&amp;<span class="built_in">log</span>.lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>commit()</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">commit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">log</span>.lh.n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    write_log();     <span class="comment">// Write modified blocks from cache to log</span></span><br><span class="line">    write_head();    <span class="comment">// Write header to disk -- the real commit</span></span><br><span class="line">    install_trans(<span class="number">0</span>); <span class="comment">// Now install writes to home locations</span></span><br><span class="line">    <span class="built_in">log</span>.lh.n = <span class="number">0</span>;</span><br><span class="line">    write_head();    <span class="comment">// Erase the transaction from the log</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_log()</code> , write all modified buf into log block.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Copy modified blocks from cache to log.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">write_log</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">to</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">from</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// cache block</span></span><br><span class="line">    memmove(to-&gt;data, from-&gt;data, BSIZE);</span><br><span class="line">    bwrite(to);  <span class="comment">// write the log</span></span><br><span class="line">    brelse(from);</span><br><span class="line">    brelse(to);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>write_head()</code>, write <code>header block</code> into disk, which is real a commit starts</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Write in-memory log header to disk.</span></span><br><span class="line"><span class="comment">// This is the true point at which the</span></span><br><span class="line"><span class="comment">// current transaction commits.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">write_head</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">buf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">logheader</span> *<span class="title">hb</span> =</span> (struct logheader *) (buf-&gt;data);</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  hb-&gt;n = <span class="built_in">log</span>.lh.n;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">log</span>.lh.n; i++) &#123;</span><br><span class="line">    hb-&gt;block[i] = <span class="built_in">log</span>.lh.block[i];</span><br><span class="line">  &#125;</span><br><span class="line">  bwrite(buf);</span><br><span class="line">  brelse(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>And left two functions is easy to understand their functionality from their name.</p><p><code>install_trans</code>, write log block into home data block.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">install_trans</span><span class="params">(<span class="keyword">int</span> recovering)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (tail = <span class="number">0</span>; tail &lt; <span class="built_in">log</span>.lh.n; tail++) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">lbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.start+tail+<span class="number">1</span>); <span class="comment">// read log block</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> *<span class="title">dbuf</span> =</span> bread(<span class="built_in">log</span>.dev, <span class="built_in">log</span>.lh.block[tail]); <span class="comment">// read dst</span></span><br><span class="line">    memmove(dbuf-&gt;data, lbuf-&gt;data, BSIZE);  <span class="comment">// copy block to dst</span></span><br><span class="line">    bwrite(dbuf);  <span class="comment">// write dst to disk</span></span><br><span class="line">    <span class="keyword">if</span>(recovering == <span class="number">0</span>)</span><br><span class="line">      bunpin(dbuf);</span><br><span class="line">    brelse(lbuf);</span><br><span class="line">    brelse(dbuf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Crash-Recovery&quot;&gt;&lt;a href=&quot;#Crash-Recovery&quot; class=&quot;headerlink&quot; title=&quot;Crash Recovery&quot;&gt;&lt;/a&gt;Crash Recovery&lt;/h3&gt;&lt;h4 id=&quot;Logging&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture12 File system on xv6</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec11--%20File%20System/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec11--%20File%20System/</id>
    <published>2022-01-30T09:02:37.096Z</published>
    <updated>2022-01-30T09:07:58.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="File-system-on-xv6"><a href="#File-system-on-xv6" class="headerlink" title="File system on xv6"></a>File system on xv6</h2><h3 id="File-system-features"><a href="#File-system-features" class="headerlink" title="File system features"></a>File system features</h3><ul><li>Abstraction</li><li>Crash Safety</li><li>Disk Layout</li><li>Performance -&gt; Because storage are slow</li></ul><h3 id="File-system-structures"><a href="#File-system-structures" class="headerlink" title="File system structures"></a>File system structures</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span>&#123;</span></span><br><span class="line">    file_info;</span><br><span class="line">    name;</span><br><span class="line">    inode_num;</span><br><span class="line">    link_count;</span><br><span class="line">    open_fd_count;<span class="comment">//File can only be deleted, if above two are 0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inode cache -&gt; mostly for synchronization     ↑</span><br><span class="line">logging                                       ｜</span><br><span class="line">buffer cache                                  ｜</span><br><span class="line">--------                                      ｜</span><br><span class="line">disk                                          ｜</span><br></pre></td></tr></table></figure><h4 id="Start-with-storage-devices"><a href="#Start-with-storage-devices" class="headerlink" title="Start with storage devices"></a>Start with storage devices</h4><p>CPU communicates to disk by PCIe, once the read/write is done, the driver will yield an interrupt. And thank to driver, in fs’s perspective, disk is like a long array<br>![](Lec11– File System/Lec11-1.png)<br>inode structure on xv6:<br>![](Lec11– File System/Lec11-2.png)</p><h4 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h4><p>In the file system, directory &lt;=&gt; file.<br>In xv6, directory entry is like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>&#123;</span></span><br><span class="line">    inum;</span><br><span class="line">    filename <span class="keyword">char</span>[<span class="number">15</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>To find a file in the directory, xv6 needs to scan over the block to match the filename. Then pickup <code>inum</code> as the inode block index.</p><p>Practically, we could use more efficient data structure to get better performance.</p><h4 id="Crash-Safety"><a href="#Crash-Safety" class="headerlink" title="Crash Safety"></a>Crash Safety</h4><p>On multi-step operation system, if crash happens during inside the transaction, we need to make sure on-disk data.<br>General solution – logging.</p><p>Risks:</p><ul><li>fs operations are multi-step <strong>disk</strong> operation</li><li>Crash may leave fs invariants violated. -&gt; need to be atomic</li><li>After reboot, fs may immediately crash agian or no crash, but r/w incorrect data.</li></ul><p>General solution – Logging:</p><ul><li>Atomic fs calls</li><li>fast recovery</li><li>high performance</li></ul><p>Logging process:</p><ul><li>Log writes</li><li>Commit op<ul><li>Note disk have a presumption that a single block or sector write  should be atomic. Namely the sector will never be written partially.</li></ul></li><li>Install  &lt;-  the installation should be idempotent</li><li>Clean log</li></ul><p>The advantage in logging is to make the transaction atomic, either we install all of operations or install nothing.  </p><p>API of xv6</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">log_write</span><span class="params">()</span><span class="comment">// write the log.lh.block[i] as the modified block number index, namely marked the blocknumber</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_log</span><span class="params">()</span><span class="comment">// copy modified blocks from cache to disk log, </span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_head</span><span class="params">()</span><span class="comment">// write header to disk -- the real commit timing</span></span></span><br></pre></td></tr></table></figure><p>If the crash happens after <code>logheader</code> is write, then when rebooting, xv6 will find the header block and check the <code>log.lh.n</code>, if it’s not zero, then we will do the recoverey to install <code>log block</code> into <code>actual block</code></p><h4 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h4><ul><li><p>Evict</p><ul><li>If bcache is full and needs to do eviction, we shouldn’t do eviction od a dirty block page</li><li>Because some pages may still inside of a transaction, so we shouldn’t evict these pages.<ul><li>The way xv6 uses, is to <code>pin</code> the block by manually incrementing the page reference. And decreasing while commiting</li></ul></li></ul></li><li><p>FS op must fit in log</p><ul><li>xv6’s log is 30 blocks, which fs operation must fit in 30 blocks before committing.</li><li>The solution is to split a big size of writing transaction into many small writes.</li><li>A question: Why we don’t require a huge atomic transaction, what if the system crashes during many small writing transaction?</li></ul></li><li><p>Concurrent fs calls</p><ul><li>If many fs calls happen at the same time, we have to make sure all concurrent ops must fit into log blocks</li><li>The way xv6 solves it is to limit the number of concurrent fs call.<ul><li>If the transaction number exceeds limit, it falls into sleep until other transactions are done.</li><li>And all the other concurrent fs calls maybe commit together, called <code>group commit</code> as a single big transaction commit</li></ul></li><li>A more general way maybe before adding one more fs transaction, do block number size check first.</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;File-system-on-xv6&quot;&gt;&lt;a href=&quot;#File-system-on-xv6&quot; class=&quot;headerlink&quot; title=&quot;File system on xv6&quot;&gt;&lt;/a&gt;File system on xv6&lt;/h2&gt;&lt;h3 id=&quot;F</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture11 Machinery about synchronize</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec10--%20synchronize/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec10--%20synchronize/</id>
    <published>2022-01-30T09:02:37.095Z</published>
    <updated>2022-01-30T09:07:44.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lec10-Machinery-about-synchronize"><a href="#Lec10-Machinery-about-synchronize" class="headerlink" title="Lec10 Machinery about synchronize"></a>Lec10 Machinery about synchronize</h2><p>Today’s lecture talks about some synchronize mechanism, from lock, condition to wait to give a clear concept of what these mechanisms really effect.</p><h3 id="Diagram-about-switch"><a href="#Diagram-about-switch" class="headerlink" title="Diagram about switch"></a>Diagram about switch</h3><p>To avoid deadlock and repeat processes while doing switch, kernel needs a right order to lock and unlock.  </p><ul><li>We need to make sure no other locks during swtch.<ul><li>Assume we have just 1 CPU and once p1 switch with 1 lock to p2, if p2 also tring to acquire the lock-&gt; deadlock</li><li>And acquire() turns off interrupt to avoid another deadlock…(because in interrupt handler, it also needs lock)</li></ul></li></ul><h3 id="Coordination-–-wake-and-sleep"><a href="#Coordination-–-wake-and-sleep" class="headerlink" title="Coordination – wake and sleep"></a>Coordination – wake and sleep</h3><p>To make thread wait on specific condition or event.<br>Given a simple example synchronize code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tx_done; <span class="comment">// has the UART finished sending?</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> tx_chan; <span class="comment">// &amp;tx_chan is the &quot;wait channel&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// transmit buf[].</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartwrite</span><span class="params">(<span class="keyword">char</span> buf[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; n)&#123;</span><br><span class="line">    <span class="keyword">while</span>(tx_done == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">// UART is busy sending a character.</span></span><br><span class="line">      <span class="comment">// wait for it to interrupt.</span></span><br><span class="line">      sleep(&amp;tx_chan, &amp;uart_tx_lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    WriteReg(THR, buf[i]);</span><br><span class="line">    i += <span class="number">1</span>;</span><br><span class="line">    tx_done = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// handle a uart interrupt, raised because input has</span></span><br><span class="line"><span class="comment">// arrived, or the uart is ready for more output, or</span></span><br><span class="line"><span class="comment">// both. called from trap.c.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">uartintr</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  acquire(&amp;uart_tx_lock);</span><br><span class="line">  <span class="keyword">if</span>(ReadReg(LSR) &amp; LSR_TX_IDLE)&#123;</span><br><span class="line">    <span class="comment">// UART finished transmitting; wake up any sending thread.</span></span><br><span class="line">    tx_done = <span class="number">1</span>;</span><br><span class="line">    wakeup(&amp;tx_chan);</span><br><span class="line">  &#125;</span><br><span class="line">  release(&amp;uart_tx_lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// read and process incoming characters.</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> c = uartgetc();</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">-1</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    consoleintr(c);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UART driver use <code>uartwrite()</code> to actually write character, we could find in code that they proceed 1 character 1 time so it needs to yield cpu instead of spin.  </p><p>UART hardware will raise interrupt to <code>uartintr</code> then wakeup  <code>uartwrite()</code> to consume character.</p><p><strong>lost wakeup</strong> is situation that one process sends wakeup signal but missed somehow by receiver. It is caused by mistakes on adding lock. If we replace sleep() by broken_sleep() which just takes one parameter indicating the sleep channel.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">broken_sleep</span><span class="params">(<span class="keyword">void</span> *chan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  acquire(&amp;p-&gt;lock);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line">  release(&amp;p-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Previous snippet will like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(tx_done == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//sleep(&amp;tx_chan, &amp;uart_tx_lock);</span></span><br><span class="line">      </span><br><span class="line">      release(&amp;uart_tx_lock);</span><br><span class="line">      <span class="comment">//lose wakeup window here!!</span></span><br><span class="line">      broken_sleep(&amp;tx_chan);</span><br><span class="line">      acquire(&amp;uart_tx_lock);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>So we need to do this three line atomically in sleep().</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">(<span class="keyword">void</span> *chan, struct spinlock *lk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Must acquire p-&gt;lock in order to</span></span><br><span class="line">  <span class="comment">// change p-&gt;state and then call sched.</span></span><br><span class="line">  <span class="comment">// Once we hold p-&gt;lock, we can be</span></span><br><span class="line">  <span class="comment">// guaranteed that we won&#x27;t miss any wakeup</span></span><br><span class="line">  <span class="comment">// (wakeup locks p-&gt;lock),</span></span><br><span class="line">  <span class="comment">// so it&#x27;s okay to release lk.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;  <span class="comment">//DOC: sleeplock0</span></span><br><span class="line">    acquire(&amp;p-&gt;lock);  <span class="comment">//DOC: sleeplock1</span></span><br><span class="line">    release(lk);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Go to sleep.</span></span><br><span class="line">  p-&gt;chan = chan;</span><br><span class="line">  p-&gt;state = SLEEPING;</span><br><span class="line"></span><br><span class="line">  sched();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tidy up.</span></span><br><span class="line">  p-&gt;chan = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reacquire original lock.</span></span><br><span class="line">  <span class="keyword">if</span>(lk != &amp;p-&gt;lock)&#123;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">    acquire(lk);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">wakeup</span><span class="params">(<span class="keyword">void</span> *chan)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++) &#123;</span><br><span class="line">    acquire(&amp;p-&gt;lock);</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;state == SLEEPING &amp;&amp; p-&gt;chan == chan) &#123;</span><br><span class="line">      p-&gt;state = RUNNABLE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;p-&gt;lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the wakeup, we have to check proc table preceding with acquiring p’s lock. So sleep with firstly get p’s lock then release <code>lk</code> to make sure all steps are atomic.</p><ul><li>Actually, semaphore is a more easier understaning way to use. Because caller have no worry about lost wakeups. (But internal semaphore, it takes good care about it)</li></ul><h3 id="exit-and-kill"><a href="#exit-and-kill" class="headerlink" title="exit and kill"></a>exit and kill</h3><p>As a process exits, we have to free memory, free pagetable and trapframe, clean up states, free stack…</p><ul><li>We cannot kill another thread directly, because it may in some critical area.</li><li>In exit(), the process should reparent its children and set its state into ZOMBIE</li><li>Parent should explicitly use wait() to reap zombie children.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">wait(uint64 addr)&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="comment">// Scan through table looking for exited children.</span></span><br><span class="line">        havekids = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(np = proc; np &lt; &amp;proc[NPROC]; np++)&#123;</span><br><span class="line">            <span class="comment">// this code uses np-&gt;parent without holding np-&gt;lock.</span></span><br><span class="line">            <span class="comment">// acquiring the lock first would cause a deadlock,</span></span><br><span class="line">            <span class="comment">// since np might be an ancestor, and we already hold p-&gt;lock.</span></span><br><span class="line">            <span class="keyword">if</span>(np-&gt;parent == p)&#123;</span><br><span class="line">                <span class="comment">// np-&gt;parent can&#x27;t change between the check and the acquire()</span></span><br><span class="line">                <span class="comment">// because only the parent changes it, and we&#x27;re the parent.</span></span><br><span class="line">                acquire(&amp;np-&gt;lock);</span><br><span class="line">                havekids = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(np-&gt;state == ZOMBIE)&#123;</span><br><span class="line">                    <span class="comment">// Found one.</span></span><br><span class="line">                    <span class="keyword">if</span>(addr != <span class="number">0</span> &amp;&amp; copyout(p-&gt;pagetable, addr, (<span class="keyword">char</span> *)&amp;np-&gt;xstate,</span><br><span class="line">                                            <span class="keyword">sizeof</span>(np-&gt;xstate)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        release(&amp;np-&gt;lock);</span><br><span class="line">                        release(&amp;p-&gt;lock);</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    freeproc(np);</span><br><span class="line">                    release(&amp;np-&gt;lock);</span><br><span class="line">                    release(&amp;p-&gt;lock);</span><br><span class="line">                    <span class="keyword">return</span> pid;</span><br><span class="line">                &#125;</span><br><span class="line">                release(&amp;np-&gt;lock);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lec10-Machinery-about-synchronize&quot;&gt;&lt;a href=&quot;#Lec10-Machinery-about-synchronize&quot; class=&quot;headerlink&quot; title=&quot;Lec10 Machinery about sync</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture10 Thread Switch</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec9--%20Thread%20Switch/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec9--%20Thread%20Switch/</id>
    <published>2022-01-30T09:02:37.093Z</published>
    <updated>2022-01-30T09:07:51.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Thread-Switch"><a href="#Thread-Switch" class="headerlink" title="Thread Switch"></a>Thread Switch</h2><p>This lecture talks about xv6’s mechanism of thread switching.  </p><h3 id="Background-knowledge"><a href="#Background-knowledge" class="headerlink" title="Background knowledge"></a>Background knowledge</h3><p>Thread : one serial execution, it should have its own <code>pc</code>, <code>registers</code> and <code>stack</code>. The scheduling system focus on the interleave multiple threads. There are two main methods to get this done, the first is using multi-cores and the second is to switch.</p><p>To deal with a computation-bound program which takes a long run to finish the job, the scheduling system uses <code>timer interrupt</code> to pre-empt the kernel then switch to another process.</p><ul><li><p>In xv6, the scheduling does is first pre-empt the kernel then voluntarily yields cpu to other process.<br>![](Lec9– Thread Switch/Lec9-pic1.png)</p></li><li><p>Recall the workflow of interrupt. Trampoline.S stores all registers and pc in trapframe.</p></li><li><p>Sometimes, in kernel, <code>kernel thread</code> just does a simple syscall and returns back to user thread by restore <code>pc</code>.</p></li><li><p>But sometimes, kernel decides to swtich to other thread.</p><ul><li>The kernel thread should save its own state, we call it <code>kernel context</code>, includes kstack and kernel registers.</li></ul></li><li><p>Two time to make context switch – time interrupt and IO waiting.</p></li></ul><h3 id="What-xv6-does"><a href="#What-xv6-does" class="headerlink" title="What xv6 does"></a>What xv6 does</h3><p>Actually, xv6’s the kernel context switch is conducted by <code>scheduler thread</code>, means kernel thread first switch to a middle thread then it chooses which process to run next.<br>The stored states includes <code>kstack pointer and pc</code>. Once the scheduler switch next process, it also has its previously stored states to be reloaded.</p><ul><li>The scheduler is pin to each CPU, so it exactly chooses which runs on the CPU</li><li>Kernel context is stored in p-&gt;context.</li><li>Scheduler’s context is stored on the structure CPU for that core.</li><li>Important, one core could just run one thread at one time and one thread can only run on one core at one time.</li></ul><h3 id="scheduler"><a href="#scheduler" class="headerlink" title="scheduler"></a>scheduler</h3><p>swtch function store the current thread’s context, includes <code>ra, sp...</code> etc.  then load the target thread context.<br>one process kernel thread -&gt; sched() -&gt; swtch to scheduler() -&gt; find a runable thread() -&gt; swtch() -&gt; other process kernel thread</p><h4 id="Some-thoughts"><a href="#Some-thoughts" class="headerlink" title="Some thoughts"></a>Some thoughts</h4><ul><li>Each child process are set a fake ra in allocproc(), because it needs a <code>ra &amp; sp</code> to be switch to and execute to set p-&gt;trapframe-&gt;epc = 0 in forkret()<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set up new context to start executing at forkret,</span></span><br><span class="line"><span class="comment">// which returns to user space.</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;p-&gt;context, <span class="number">0</span>, <span class="keyword">sizeof</span>(p-&gt;context));</span><br><span class="line">p-&gt;context.ra = (uint64)forkret;</span><br><span class="line">p-&gt;context.sp = p-&gt;kstack + PGSIZE;</span><br></pre></td></tr></table></figure></li><li>In xv6, even in the scheduler, the kernel turns on the interrupt to provent kernel from deadlock.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Thread-Switch&quot;&gt;&lt;a href=&quot;#Thread-Switch&quot; class=&quot;headerlink&quot; title=&quot;Thread Switch&quot;&gt;&lt;/a&gt;Thread Switch&lt;/h2&gt;&lt;p&gt;This lecture talks about x</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture9 Lock</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec8--%20Lock/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec8--%20Lock/</id>
    <published>2022-01-30T09:02:37.091Z</published>
    <updated>2022-01-30T09:06:45.845Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Locks"><a href="#Locks" class="headerlink" title="Locks"></a>Locks</h2><p>This lecture talks about locks, I believe many people already have the concept of locks. So I just skip the very beginning of the lecture.</p><h3 id="Basic-lock-guideline"><a href="#Basic-lock-guideline" class="headerlink" title="Basic lock guideline"></a>Basic lock guideline</h3><p>A consecuative rule: 2 processes accessing a shared data structure.<br>If one is a writer=&gt; lock data structure is needed.  </p><ul><li>Too strict: there is a style called lock-free programming. Isn’t all situation needed lock</li><li>Too loose: Some situation are no shared memory but still need lock</li></ul><h3 id="Some-problems"><a href="#Some-problems" class="headerlink" title="Some problems"></a>Some problems</h3><ul><li>Deadlock<ul><li>When two process trying to acquire the lock holded by other, deadlock may happen (Not strict definition)</li></ul></li><li>Lock vs Modularity<ul><li>Lock ordering needes the lock are global.</li><li>If exists m1.g() calls m2.f() which uses lock. Then f()’s lock need to be visible to m1. Violates abstract principle.</li></ul></li><li>Lock vs performance<ul><li>Need to split up data structure</li><li>Best split is a challenge</li><li>A better way to find the practical lock granularity.<ul><li>Start with coarse-grained locks </li><li>Meassure the performance</li><li>If multiple thread are trying to get lock -&gt; serialized -&gt; need redesign</li></ul></li></ul></li></ul><h3 id="The-implementation-of-lock"><a href="#The-implementation-of-lock" class="headerlink" title="The implementation of lock"></a>The implementation of lock</h3><p><strong>Spinlock</strong><br>Need hw support, test and set instruction<br>test_and_set(addr, r1, r2):<br>lock()<br>&ensp;&ensp;&ensp;tmp &lt;- [addr]<br>&ensp;&ensp;&ensp;[arr] &lt;- r1<br>&ensp;&ensp;&ensp;r2   &lt;- tmp<br>unlock()<br>return r2<br>c std function -&gt; __sync_lock_test_and_set(void*, int)</p><h3 id="Memory-layout"><a href="#Memory-layout" class="headerlink" title="Memory layout"></a>Memory layout</h3><p>Due to compiler optimzation, some instructions could be resorted and exectued in different sequential than original written one.<br>The spinlock could use __sync_synchronize() function to denote between two <code>barrier</code>, compiler shouldn’t rearrange any instruction order.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Locks&quot;&gt;&lt;a href=&quot;#Locks&quot; class=&quot;headerlink&quot; title=&quot;Locks&quot;&gt;&lt;/a&gt;Locks&lt;/h2&gt;&lt;p&gt;This lecture talks about locks, I believe many people alre</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture8 Interrupt</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec7--%20Interrupt/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec7--%20Interrupt/</id>
    <published>2022-01-30T09:02:37.090Z</published>
    <updated>2022-01-30T09:06:41.353Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Interrupt"><a href="#Interrupt" class="headerlink" title="Interrupt"></a>Interrupt</h2><h3 id="RISCV-interrupt-related-registers"><a href="#RISCV-interrupt-related-registers" class="headerlink" title="RISCV interrupt-related registers"></a>RISCV interrupt-related registers</h3><p>SIE – supervisor interrupt enabled register, 3 bits for software int, external int and timer int.<br>SSTATUS – supervior status register, one bit to enable interrupts.<br>SIP – supervisor interrupt pending register<br>SCAUSE – supervisor cause register<br>STVEC – supervisor trap vector register<br>MDELEG – machine delegate register</p><h3 id="Use-of-PLIC"><a href="#Use-of-PLIC" class="headerlink" title="Use of PLIC"></a>Use of PLIC</h3><p>PLIC, platform-level interrupt controller, passes interrupt on to a CPU. It is the handler of interrupts, that distributes interrupts among cores. If no CPU claims the interrupt, the interrupt stays pending till eventually be delivered to some core.</p><h3 id="Concurrency-external-device"><a href="#Concurrency-external-device" class="headerlink" title="Concurrency external device"></a>Concurrency external device</h3><p>In the RISCV xv6, external devices are running parallelly with kernel and controlled by <code>driver</code>. The way device used to communicate with kernel, is interrupt which has three properties:</p><ul><li>Asynchronous<ul><li>interrupts running process</li><li>interrupt handler may not run in context of process who caused interrupt.</li></ul></li><li>Concurrency<ul><li>devices and process run in parallel</li></ul></li><li>Programming devices<ul><li>device can be difficult to program</li></ul></li></ul><p>Refer to xv6-book, we have the definition of driver:</p><blockquote><p>Many device drivers execute code in two contexts: a top half that runs in a process’s kernel<br>thread, and a bottom half that executes at interrupt time. The top half is called via system calls<br>such as read and write that want the device to perform I/O. This code may ask the hardware<br>to start an operation (e.g., ask the disk to read a block); then the code waits for the operation<br>to complete. Eventually the device completes the operation and raises an interrupt. The driver’s<br>interrupt handler, acting as the bottom half, figures out what operation has completed, wakes up a<br>waiting process if appropriate, and tells the hardware to start work on any waiting next operation.</p></blockquote><p>In the lecture, the professor uses one case to walk through the workflow of <code>UART</code>, and the xv6-book also writes the detailed explanation of how kernel interacts with devices.<br>I just want to write down some ideas attracts me most during the lecture.</p><ul><li>Each device is mapped to a physical memory address. And there are handful of control register on it, like<code>RHR</code>(receive holding register) and <code>THR</code>(transmit holding register)…</li><li>Both user type a byte input and UART completes sending a byte both raise a interrupt.</li><li>To display a character, driver puts character into UART’s send FIFO then interrupt when character has been sent</li><li>To receive a keyboard hit, user hits key then returns in UART interrupt. Driver gets character from UART’s receive FIFO</li></ul><h3 id="polling"><a href="#polling" class="headerlink" title="polling"></a>polling</h3><p>Consider the fact that nowadays some devices generate events faster than one per microsecond, eg. gigabit ethernet can deliver 1.5 million small packets / second.</p><p>The way to deal with those huge amount of interrupts is polling – processor spins until device wants attention.</p><ul><li>Wastes processor cycles if device is slow</li><li>But inexpensive if device is fast<ul><li>No saving of regiser, etc</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Interrupt&quot;&gt;&lt;a href=&quot;#Interrupt&quot; class=&quot;headerlink&quot; title=&quot;Interrupt&quot;&gt;&lt;/a&gt;Interrupt&lt;/h2&gt;&lt;h3 id=&quot;RISCV-interrupt-related-registers&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lec7 Page Fault</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec6--%20Page%20Fault/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec6--%20Page%20Fault/</id>
    <published>2022-01-30T09:02:37.088Z</published>
    <updated>2022-01-30T09:06:36.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Page-Fault"><a href="#Page-Fault" class="headerlink" title="Page Fault"></a>Page Fault</h2><h3 id="Virtual-Memory"><a href="#Virtual-Memory" class="headerlink" title="Virtual Memory"></a>Virtual Memory</h3><p>Two advantages:  </p><ul><li>Isolations: Because of the exist of <code>satp</code>, two different processes can’t visit other’s physical memory</li><li>Memory Indirection: The mapping from va -&gt; pa, provides us many interesting features like, page fault, demanding, lazy allocation…</li></ul><h3 id="sbrk"><a href="#sbrk" class="headerlink" title="sbrk()"></a>sbrk()</h3><p>Grow(or shrink) the heap from lower to higher place(or h -&gt; l)<br>Two allocations methods:  </p><ul><li>Eager Allocation: Allocate the memory immediately once sbrk() is called.</li><li>Lazy Allocation: Allocate the memory only when the memory is used(writed).</li></ul><p>But the situation is that many programmer don’t know the exact space they need, so they tend to allocate the maximum space. -&gt; lazy allocation is better.  </p><p>In xv6, lazy allocation should just bump up the p-&gt;sz and only alloc() space when the page is needed.</p><h3 id="zero-fill-on-demand"><a href="#zero-fill-on-demand" class="headerlink" title="zero-fill on demand"></a>zero-fill on demand</h3><p>In the convention of c language, <code>bss</code> which stands for <code>block starting symbol</code> is the portion of an object file that contains statically allocated variables that are declared but have not been assigned value yet.  </p><p>So the lazy allocation could do is that, in the virtual address there might be many BSS pages, and we could page them to one same page on physical memory(one zero page).</p><p>Once a bss page requries to write something on the page, the kernel yields a page fault and allocate a new physical all-zero page then remap the va to this page then return to user.<br>![](Lec6– Page Fault/Lec6-2.png)<br>Pros:</p><ul><li>Similar to lazy allocation(space saving)</li><li>Quick execute because don’t have to initialize many pages at beginning.</li></ul><h3 id="copy-on-write-fork"><a href="#copy-on-write-fork" class="headerlink" title="copy-on-write fork"></a>copy-on-write fork</h3><p>The basic idea is the child process and parent process are sharing the same physical address at beginning.  </p><p>At somepoint once child/parent wants to do some modification on one page(let’s assume child). The kernel will detect the access to the physical page and try to allocate a new page copy for the child, (because in fork() all pages’ PTE are set to READ_ONLY, the write acess will cause trap<br>). After the allocation, this specific va of child and parent’s PTE will be READ &amp; WRITE as normal.</p><p>![](Lec6– Page Fault/Lec6-1.png)</p><h3 id="Demaning-page"><a href="#Demaning-page" class="headerlink" title="Demaning page"></a>Demaning page</h3><p>In exec(), we could load <code>text and data</code> not so eagerly that we can just set the virtual address but leave PTE_V as 0. So once the page is visited, it will yields a page fault then the kernel finally load the page from disk.</p><ul><li>Set page table, PTE_V = 0</li><li>After page fault<ul><li>read block/page from file into memory</li><li>map the memory into pgtbl</li><li>restart instruction</li></ul></li></ul><p>Then we may also get into  out-of-memory situation, so LRU and other eviction policies may be involved.</p><h3 id="Memory-mapped-files"><a href="#Memory-mapped-files" class="headerlink" title="Memory-mapped files"></a>Memory-mapped files</h3><p>mmap(va, len, protection, flags, fd, off)<br>unmap(va, len) </p><p>do this lazily by store the mmap in <code>vma</code> (virtual memory area) maintains <code>fd, prot, va, off...</code> .</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Page-Fault&quot;&gt;&lt;a href=&quot;#Page-Fault&quot; class=&quot;headerlink&quot; title=&quot;Page Fault&quot;&gt;&lt;/a&gt;Page Fault&lt;/h2&gt;&lt;h3 id=&quot;Virtual-Memory&quot;&gt;&lt;a href=&quot;#Virtual</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lecture6 Isolation and syscall</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lec5--%20Trap/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lec5--%20Trap/</id>
    <published>2022-01-30T09:02:37.086Z</published>
    <updated>2022-01-30T09:06:26.148Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lec6-Isolation-and-syscall"><a href="#Lec6-Isolation-and-syscall" class="headerlink" title="Lec6- Isolation and syscall"></a>Lec6- Isolation and syscall</h2><h3 id="Supervisor-registers"><a href="#Supervisor-registers" class="headerlink" title="Supervisor registers"></a>Supervisor registers</h3><ul><li>stap – Store the page table’s base address</li><li>stvec – Store the address of trap program – <code>trampolines</code>, note that this address is mapped on user’s page table but without <code>PTE_U</code> which means the user can’t modify it.</li><li>sepc – Store the address in the user mode when ecall happens</li><li>sstrach – Store the address of <code>trapframe</code> which stores a frame useds to temporarily keep the user’s registers. Also used as swap “transfer station” register. <ul><li>See the usage of <code>csrrw a0, sstrach, a0</code> in the trampoline.S for some examples.</li></ul></li></ul><h3 id="Work-Flow"><a href="#Work-Flow" class="headerlink" title="Work Flow"></a>Work Flow</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">user_syscall()</span><br><span class="line">    ecall</span><br><span class="line">------------------------------↓----------------------------------</span><br><span class="line">uservec-trampoline        userret()</span><br><span class="line">  ↓                     ↑</span><br><span class="line">  usertrap()           usertrapret()</span><br><span class="line">      ↓                     ↑</span><br><span class="line">   syscall()   --------------</span><br><span class="line">     ↓  ↑</span><br><span class="line">    specific SYS_call()</span><br></pre></td></tr></table></figure><p>Some interesting features:</p><ul><li><p>When user functions use ecall trying to enter kernel mode, what the RISCV actually does is just fetch the address at <code>stvec</code> and jump to that address and execute.</p><ul><li><p>Ecall fetches the value from <code>stvec</code> and saves the <code>pc</code> in the <code>sepc</code>.</p></li><li><p>You shall see the page table haven’t been changed after ecall.</p></li><li><p><code>stvec</code> register keep the address of <code>trampoline</code></p></li><li><p>The last two line in the page table are exactly the kernel mode’s code, but mapped at user’s page table. Note PTE_U are not set, so user mode can’t access them.</p><p>![image-20211223103538097](Lec5– Trap/lec5-1.png)</p></li></ul></li><li><p><code>trampoline</code> are the two-direction bridge for both user and kernel, because its physical address for user and kernel are both map to the same virtual address.</p><ul><li><p>Based on above handy design, we could do <code>satp</code> change and save 32 register into <code>trapframe</code>.</p></li><li><p>Note that <code>sstrach</code> initially store the address of <code>trapframe</code> then swap the content with a0.</p></li><li><p>Finally load kernel stack pointer and usertrap address then jump to kernel c code.</p></li></ul></li><li><p><code>trap.c</code> checks the reason of the trap and redirect the following trap to jump tp <code>kernelvec</code> instead of trampoline. Then it analysis the cause number (in lecture’s example, we use syscall, so # is 8)</p><ul><li>For syscall, what <code>usertrap()</code> does is jump to syscall() function and syscall() will change the trapframe-&gt;a0’s value to make it received by user as the return value.</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lec6-Isolation-and-syscall&quot;&gt;&lt;a href=&quot;#Lec6-Isolation-and-syscall&quot; class=&quot;headerlink&quot; title=&quot;Lec6- Isolation and syscall&quot;&gt;&lt;/a&gt;Lec6- I</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab11</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab11%20NIC/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab11%20NIC/</id>
    <published>2022-01-30T09:02:37.084Z</published>
    <updated>2022-01-30T09:04:33.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Networking"><a href="#Networking" class="headerlink" title="Networking"></a>Networking</h3><p>In this lab, we will program on <strong>NIC</strong> driver to control packet receive and transmit process. Because the lab has a detailed description of how to do the lab, I’ll just put on our code and explain some key points in the lab.</p><h4 id="Code-Part"><a href="#Code-Part" class="headerlink" title="Code Part"></a>Code Part</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_transmit</span><span class="params">(struct mbuf *m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// the mbuf contains an ethernet frame; program it into</span></span><br><span class="line">  <span class="comment">// the TX descriptor ring so that the e1000 sends it. Stash</span></span><br><span class="line">  <span class="comment">// a pointer so that it can be freed after sending.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  acquire(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">int</span> txport = regs[E1000_TDT];</span><br><span class="line">  <span class="keyword">if</span>(tx_ring[txport].status != E1000_TXD_STAT_DD)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;haven&#x27;t found a packet\n&quot;</span>);</span><br><span class="line">    release(&amp;e1000_lock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(tx_mbufs[txport])&#123;</span><br><span class="line">    mbuffree(tx_mbufs[txport]);</span><br><span class="line">  &#125;</span><br><span class="line">  tx_mbufs[txport] = m;</span><br><span class="line">  tx_ring[txport].addr = (uint64)m-&gt;head;</span><br><span class="line">  tx_ring[txport].length = m-&gt;len;</span><br><span class="line">  tx_ring[txport].cmd = E1000_TXD_CMD_EOP | E1000_TXD_CMD_RS;</span><br><span class="line"></span><br><span class="line">  regs[E1000_TDT] = (txport + <span class="number">1</span>) % TX_RING_SIZE;</span><br><span class="line">  release(&amp;e1000_lock);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">e1000_recv</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Your code here.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Check for packets that have arrived from the e1000</span></span><br><span class="line">  <span class="comment">// Create and deliver an mbuf for each packet (using net_rx()).</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">int</span> next_idx = (regs[E1000_RDT] + <span class="number">1</span>) % RX_RING_SIZE;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == (rx_ring[next_idx].status &amp; E1000_RXD_STAT_DD))&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    rx_mbufs[next_idx]-&gt;len = rx_ring[next_idx].length;</span><br><span class="line">    net_rx(rx_mbufs[next_idx]);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mbuf</span> *<span class="title">new</span> =</span> mbufalloc(<span class="number">0</span>);</span><br><span class="line">    rx_ring[next_idx].addr = (uint64)<span class="keyword">new</span>-&gt;head;</span><br><span class="line">    rx_ring[next_idx].status = <span class="number">0</span>;</span><br><span class="line">    rx_mbufs[next_idx] = <span class="keyword">new</span>;</span><br><span class="line">    regs[E1000_RDT] = next_idx;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Network-Architecture"><a href="#Network-Architecture" class="headerlink" title="Network Architecture"></a>Network Architecture</h4><h5 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h5><p>![image-20220130143403111](Lab11 NIC/lab11-1.png)</p><p>Ethernet frame struct: start flag + 48 bits target eth address + 48bits source eth address + 16bits ether type + payload + end flag</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eth</span>&#123;</span></span><br><span class="line">    uint8 dhost[ETHADDR_LEN];</span><br><span class="line">    uint8 shost[ETHADDR_LEN];</span><br><span class="line">    uint64 type;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><p>To transmit packet to remote Host, we need IP address and ARP protocol to translate IP address into eth address. ARP header is nested included in ethernet packet.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">arp</span> &#123;</span></span><br><span class="line">  uint16 hrd; <span class="comment">// format of hardware address</span></span><br><span class="line">  uint16 pro; <span class="comment">// format of protocol address</span></span><br><span class="line">  uint8  hln; <span class="comment">// length of hardware address</span></span><br><span class="line">  uint8  pln; <span class="comment">// length of protocol address</span></span><br><span class="line">  uint16 op;  <span class="comment">// operation</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>   sha[ETHADDR_LEN]; <span class="comment">// sender hardware address</span></span><br><span class="line">  uint32 sip;              <span class="comment">// sender IP address</span></span><br><span class="line">  <span class="keyword">char</span>   tha[ETHADDR_LEN]; <span class="comment">// target hardware address</span></span><br><span class="line">  uint32 tip;              <span class="comment">// target IP address</span></span><br><span class="line">&#125; __attribute__((packed));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ARP_HRD_ETHER 1 <span class="comment">// Ethernet</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  ARP_OP_REQUEST = <span class="number">1</span>, <span class="comment">// requests hw addr given protocol addr</span></span><br><span class="line">  ARP_OP_REPLY = <span class="number">2</span>,   <span class="comment">// replies a hw addr given protocol addr</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="IP-amp-UDP"><a href="#IP-amp-UDP" class="headerlink" title="IP &amp; UDP"></a>IP &amp; UDP</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// an IP packet header (comes after an Ethernet header).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ip</span> &#123;</span></span><br><span class="line">  uint8  ip_vhl; <span class="comment">// version &lt;&lt; 4 | header length &gt;&gt; 2</span></span><br><span class="line">  uint8  ip_tos; <span class="comment">// type of service</span></span><br><span class="line">  uint16 ip_len; <span class="comment">// total length</span></span><br><span class="line">  uint16 ip_id;  <span class="comment">// identification</span></span><br><span class="line">  uint16 ip_off; <span class="comment">// fragment offset field</span></span><br><span class="line">  uint8  ip_ttl; <span class="comment">// time to live</span></span><br><span class="line">  uint8  ip_p;   <span class="comment">// protocol</span></span><br><span class="line">  uint16 ip_sum; <span class="comment">// checksum</span></span><br><span class="line">  uint32 ip_src, ip_dst;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// a UDP packet header (comes after an IP header).</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">udp</span> &#123;</span></span><br><span class="line">  uint16 sport; <span class="comment">// source port</span></span><br><span class="line">  uint16 dport; <span class="comment">// destination port</span></span><br><span class="line">  uint16 ulen;  <span class="comment">// length, including udp header, not including IP header</span></span><br><span class="line">  uint16 sum;   <span class="comment">// checksum</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Kernel-Network-Stack"><a href="#Kernel-Network-Stack" class="headerlink" title="Kernel Network Stack"></a>Kernel Network Stack</h4><p>![image-20220130150540694](Lab11 NIC/Lab11-2.png)</p><p>Each layer will stripe out and check the header according to the its own protocol from <code>mbuf</code> ‘s cached packet to achieve nesting.</p><h4 id="MAC-chip"><a href="#MAC-chip" class="headerlink" title="MAC chip"></a>MAC chip</h4><p>![image-20220130151743600](Lab11 NIC/lab11-3.png)</p><p>DMA could directly visit memory without interact with CPU, <strong>DMA Engine</strong> controls PCI bus to transmit between memory and FIFO data buffer.</p><p><strong>Transmit steps:</strong></p><p>CPU put IP packet into memory and ask <em>DMA Engine</em> to do DMA transmit into <em>FIFO buffer</em>. Then MAC chip splits IP packet into <em>Data frame</em> whose size in range[64KB, 1518KB]. Each frame includes <code>Target MAC</code> <code>Source MAC</code> <code>Protocol type</code> <code>CRC checksum</code>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Networking&quot;&gt;&lt;a href=&quot;#Networking&quot; class=&quot;headerlink&quot; title=&quot;Networking&quot;&gt;&lt;/a&gt;Networking&lt;/h3&gt;&lt;p&gt;In this lab, we will program on &lt;stron</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab10</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab10%20Mmap/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab10%20Mmap/</id>
    <published>2022-01-30T09:02:37.082Z</published>
    <updated>2022-01-30T09:04:20.193Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lab10-Mmap"><a href="#Lab10-Mmap" class="headerlink" title="Lab10 Mmap"></a>Lab10 Mmap</h3><p>In this lab,  we need to develop a <code>weak</code> <code>mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset)</code>, which have no designated <code>addr</code> and <code>prot</code> and <code>flags</code> are also limited to <code>READ, WRITE and both</code> and <code>SHARED and PRIVATE</code>. </p><p>Also, we have to implement <code>munmap(void *addr, size_t length)</code>, which won’t punch a hole in the middle of a region.</p><p>To make mmap fast return, we won’t allocate any physical pages for a mmap call, and instead, we just put the call into a <code>vma</code> slot contains its meta information.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma</span>&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span>* <span class="title">f</span>;</span> <span class="comment">//file handler pointer</span></span><br><span class="line">  uint64 vstart;  <span class="comment">//start location in virtual memory</span></span><br><span class="line">  uint64 length;  <span class="comment">//File size</span></span><br><span class="line">  uint64 offset;  <span class="comment">//start location&#x27;s offset</span></span><br><span class="line">  <span class="keyword">int</span> valid;      <span class="comment">//Is this slot valid?</span></span><br><span class="line">  <span class="keyword">int</span> perm;  <span class="comment">//Permission : WRITE / READ</span></span><br><span class="line">  <span class="keyword">int</span> flags;      <span class="comment">//MAP_SHARED / MAP_PRIVATE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the lab website, lecturer has given us detailed information about how to write the code. And I want to introduce my design method which may be helpful to understand how to actually implement mmap.</p><p>I will throw some questions to help (you or me later) to understand why I do this</p><ul><li>Where to put <code>vma</code> in the memory?</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">At first I want to let vma increase with proc-&gt;sz, which means each time a mmap is called we need to reserve some `complete 4k size` in user memory to be physically allcoated. </span><br><span class="line">So I decided to put vma slots in the high space of heap</span><br></pre></td></tr></table></figure><p>![image-20220116135201384](Lab10 Mmap/lab10-1.png)</p><ul><li>When to allocate the physical page</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In the mmap() call, we just select an empty vma slot and put this information into the slot then return.</span><br><span class="line">When a page_fault is captured by usertrap(), if the accessing va is inside some vma. Then allocate a 4k page at va&#x27;s page.</span><br><span class="line">We should have a do_mmap() function like following:</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_mmap</span><span class="params">(struct vma* mmap, uint64 va)</span></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> * <span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Current va :%p, perm : %x\n&quot;</span>, va, mmap-&gt;perm);</span><br><span class="line">  <span class="comment">//Need to do the alloc first</span></span><br><span class="line">  uint64 pa = (uint64)kalloc();</span><br><span class="line">  <span class="built_in">memset</span>((<span class="keyword">void</span>*)pa, <span class="number">0</span>, PGSIZE);</span><br><span class="line"></span><br><span class="line">  ilock(mmap-&gt;f-&gt;ip);</span><br><span class="line">  <span class="keyword">if</span>(readi(mmap-&gt;f-&gt;ip, <span class="number">0</span>, pa, mmap-&gt;offset + PGROUNDDOWN(va - mmap-&gt;vstart), PGSIZE) == <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;do_mmap failed!\n&quot;</span>);</span><br><span class="line">  iunlock(mmap-&gt;f-&gt;ip);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(mappages(p-&gt;pagetable, va, PGSIZE, pa, (mmap-&gt;perm &lt;&lt; <span class="number">1</span>) | PTE_U) &lt; <span class="number">0</span>)</span><br><span class="line">    panic(<span class="string">&quot;dp_mmap(): mappages()\n&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;do_mmap() finished\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>When allocate a physical page, we need to implement our own <code>uvmalloc</code> function to set the permission flags.</li><li>How to deal with munmap?<ul><li>In this lab, we just need to deal with 3 situation:<ul><li>free from beginning to some point before end</li><li>free from some point after start to the end</li><li>free all</li></ul></li><li>What should we do while unmaping?<ul><li>free whole 4k page if the entire 4k range is unmaped.</li><li>If the 4k is being freed, we have to write back the content if <code>flag</code> set as <code>MAP_SHARED</code></li><li>If the beginning is free, we have to redirect <code>vma-&gt;offset</code> ,  so when read from file, the true <code>file offset</code> should be <code>va - vma-&gt;vstart + vma-&gt;offset</code></li></ul></li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">sys_munmap()&#123;</span><br><span class="line">    ...</span><br><span class="line">  uint64 addr_aligned = ip;</span><br><span class="line">  <span class="keyword">if</span>(ip &gt; v-&gt;vstart)&#123;</span><br><span class="line">    addr_aligned = PGROUNDUP(ip);</span><br><span class="line">    length -= addr_aligned - ip;</span><br><span class="line">    <span class="comment">//free not at head</span></span><br><span class="line">    uvmunmap2(p-&gt;pagetable,addr_aligned, PGROUNDUP(length) / PGSIZE, v);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip + length &gt;= v-&gt;vstart + v-&gt;length)&#123;</span><br><span class="line">    <span class="comment">//free all</span></span><br><span class="line">    uvmunmap2(p-&gt;pagetable, PGROUNDDOWN(ip), PGROUNDUP(length) / PGSIZE, v);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//free at beginning, but not to the end</span></span><br><span class="line">    <span class="keyword">if</span>(PGROUNDDOWN(ip + length) &gt; PGROUNDDOWN(ip))&#123;</span><br><span class="line">      uvmunmap2(p-&gt;pagetable, PGROUNDDOWN(ip), PGROUNDUP(length) / PGSIZE, v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(ip &lt;= v-&gt;vstart &amp;&amp; ip + length &gt; v-&gt;vstart)&#123;</span><br><span class="line">    <span class="comment">//modify offset</span></span><br><span class="line">    v-&gt;offset += ip + length - v-&gt;offset; </span><br><span class="line">    v-&gt;vstart = ip +length;</span><br><span class="line">  &#125;</span><br><span class="line">  v-&gt;length -= length;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(v-&gt;length &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">    fileclose(v-&gt;f);</span><br><span class="line">    v-&gt;valid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>To deal with fork, although we copy vma from old to new, new pagetable won’t have to the corresponding pte on it. Because it just copy the pte range from [0, p-&gt;sz].</li><li>Don’t forget to wipe out valid when proc is freed.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lab10-Mmap&quot;&gt;&lt;a href=&quot;#Lab10-Mmap&quot; class=&quot;headerlink&quot; title=&quot;Lab10 Mmap&quot;&gt;&lt;/a&gt;Lab10 Mmap&lt;/h3&gt;&lt;p&gt;In this lab,  we need to develop a &lt;co</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab9</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab9%20Multithreading/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab9%20Multithreading/</id>
    <published>2022-01-30T09:02:37.080Z</published>
    <updated>2022-01-30T08:52:02.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab9-–-Multithreading"><a href="#Lab9-–-Multithreading" class="headerlink" title="Lab9 – Multithreading"></a>Lab9 – Multithreading</h2><h3 id="User-thread-implementation"><a href="#User-thread-implementation" class="headerlink" title="User thread implementation"></a>User thread implementation</h3><p>In this section, we will implement a user-level thread. Like many user-level thread libraries do, it should have its own<br><code>pc, reregister and stack</code>. For each thread, lab has already written the storage area in the <code>struct thread</code>.  </p><p>But because we still needs to save / restore the register through <code>thread_switch</code>, we also need a <code>struct thread_context</code> to store register status.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_context</span>&#123;</span></span><br><span class="line">  uint64 ra;</span><br><span class="line">  uint64 sp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// callee-saved</span></span><br><span class="line">  uint64 s0;</span><br><span class="line">  uint64 s1;</span><br><span class="line">  uint64 s2;</span><br><span class="line">  uint64 s3;</span><br><span class="line">  uint64 s4;</span><br><span class="line">  uint64 s5;</span><br><span class="line">  uint64 s6;</span><br><span class="line">  uint64 s7;</span><br><span class="line">  uint64 s8;</span><br><span class="line">  uint64 s9;</span><br><span class="line">  uint64 s10;</span><br><span class="line">  uint64 s11;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Like what kernel does in kernel/swtch.S(), we copy the context switch assembly code to save <code>ra, sp and callee saved registers</code>.  </p><p>In our implementation, <code>ra</code> is used to store the return address of thread_switch.S namely the last switch out point’s address. Cooperates with ra, <code>sp</code> provides stack pointer points to stack which stores more variables on stack.</p><p>Finally, we have to define where <code>ra</code> and <code>sp</code> starts.<br>D note <code>sp</code> grows from high to low, so we need to set <code>sp = &amp;state</code> and <code>ra</code> as the address of <code>func</code></p><h3 id="Using-thread"><a href="#Using-thread" class="headerlink" title="Using thread"></a>Using thread</h3><p>Last two sections require us to do coding on pthread. Some main API are following:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> lock;            <span class="comment">// declare a lock</span></span><br><span class="line"><span class="built_in">pthread_mutex_init</span>(&amp;lock, <span class="literal">NULL</span>); <span class="comment">// initialize the lock</span></span><br><span class="line"><span class="built_in">pthread_mutex_lock</span>(&amp;lock);       <span class="comment">// acquire lock</span></span><br><span class="line"><span class="built_in">pthread_mutex_unlock</span>(&amp;lock);     <span class="comment">// release lock</span></span><br><span class="line"><span class="built_in">pthread_cond_wait</span>(&amp;cond, &amp;mutex);  <span class="comment">// go to sleep on cond, releasing lock mutex, acquiring upon wake up</span></span><br><span class="line"><span class="built_in">pthread_cond_broadcast</span>(&amp;cond);     <span class="comment">// wake up every thread sleeping on cond</span></span><br></pre></td></tr></table></figure><p>Actually I don’t want talk much about these because they are so easy for me? Maybe <code>Barrier</code>  is worthy a concise description.</p><p>To make all threads block till all of them synchronize at one point, we need <code>pthread_cond_wait()</code> and <code>pthread_cond_broadcase()</code>.  </p><p>In each round, if reached thread number are not enough, then they call <code>cond_wait()</code> to release the lock and sleep. Till the last thread reaches, it increment round and set 0 the thread counter then <code>cond_broadcast()</code>.</p><p>Note, don’t forget to unlock properly.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab9-–-Multithreading&quot;&gt;&lt;a href=&quot;#Lab9-–-Multithreading&quot; class=&quot;headerlink&quot; title=&quot;Lab9 – Multithreading&quot;&gt;&lt;/a&gt;Lab9 – Multithreading&lt;/</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab8</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab8--%20File%20System/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab8--%20File%20System/</id>
    <published>2022-01-30T09:02:37.078Z</published>
    <updated>2022-01-30T08:51:28.145Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lab8-file-system"><a href="#Lab8-file-system" class="headerlink" title="Lab8 file system"></a>Lab8 file system</h3><h4 id="Large-files"><a href="#Large-files" class="headerlink" title="Large files"></a>Large files</h4><p>Implement “doubly-indirect” block in the inode, to make each inode be able to contain <code>256*256+256+11</code> blocks. Recall the definition of inode and how <code>direct and indirect block</code> works. This lab is much easy to accomplish.</p><p>Just follow the <em>hints</em> and modify the <code>dinode</code> and <code>inode</code> for the new <code>double-indirect</code> block. </p><h4 id="Symbolic-links"><a href="#Symbolic-links" class="headerlink" title="Symbolic links"></a>Symbolic links</h4><p>The following sentence refers to manual page in linux of symlink.</p><h5 id="man-symlink"><a href="#man-symlink" class="headerlink" title="man symlink"></a>man symlink</h5><blockquote><p>symlink() creates a symbolic link named linkpath which contains the string target.</p><p> Symbolic links are interpreted at run time as if the contents of the link had been substituted into the path being followed to find a file or directory.</p><p> Symbolic links may contain ..  path components, which (if used at the start of the link) refer to the parent directories of that in which the link resides.</p><p> A symbolic link (also known as a soft link) may point to an existing file or to a nonexistent one; the latter case is known as a dangling link.</p><p> The permissions of a symbolic link are irrelevant; the ownership is ignored when following the link, but is checked when removal or renaming of the link is requested and the link is in a directory with the sticky bit (S_ISVTX) set.</p><p>If linkpath exists, it will not be overwritten.</p></blockquote><h5 id="man-open-about-O-NOFOLLOW"><a href="#man-open-about-O-NOFOLLOW" class="headerlink" title="man open (about O_NOFOLLOW)"></a>man open (about O_NOFOLLOW)</h5><blockquote><p>If pathname is a symbolic link, then the open fails, with the error ELOOP.  Symbolic links in earlier components of the pathname will still be followed.  (Note  that  the <strong>ELOOP</strong> error that can occur in this case is indistinguishable from the case where an open fails because there are too many symbolic links found while resolving components in the prefix part of the pathname.)</p></blockquote><p>So if <strong>open()</strong> calls for some file with <code>O_NOFOLLOW</code> just ignore the symbolic link flag and directly return the block. If without <code>O_NOFOLLOW</code> , we need do search recursively till find the first non-symlink inode or exceed 10-depth limit.</p><p>In order to do so, firstly implement <code>sys_symlink()</code>:</p><p>I put  the symlink information into the first block of the inode.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64 <span class="title">sys_symlink</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> target[MAXPATH], path[MAXPATH];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">ip</span>;</span></span><br><span class="line">  <span class="keyword">if</span>(argstr(<span class="number">0</span>, target, MAXPATH) &lt; <span class="number">0</span> || argstr(<span class="number">1</span>, path, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  begin_op();</span><br><span class="line">  <span class="comment">//To create a symlink in path</span></span><br><span class="line">  ip = create(path, T_SYMLINK, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(writei(ip, <span class="number">0</span>, (uint64)target, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    iunlockput(ip);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  iunlockput(ip);</span><br><span class="line"></span><br><span class="line">  end_op();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then to open a path which may be a symbolic link on it:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(omode &amp; O_CREATE)&#123;</span><br><span class="line">  ip = create(path, T_FILE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(ip == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">    end_op();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ilock(ip);</span><br><span class="line">  <span class="keyword">while</span>(ip-&gt;type == T_SYMLINK)&#123;</span><br><span class="line">    <span class="keyword">if</span>((omode &amp; O_NOFOLLOW) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="comment">//follow sym link</span></span><br><span class="line">      <span class="keyword">if</span>(++depth &gt; <span class="number">10</span>)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(readi(ip, <span class="number">0</span>, (uint64)path, <span class="number">0</span>, MAXPATH) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        iunlockput(ip);</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      iunlockput(ip);</span><br><span class="line">      <span class="keyword">if</span>((ip = namei(path)) == <span class="number">0</span>)&#123;</span><br><span class="line">        end_op();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125; </span><br><span class="line">      ilock(ip);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lab8-file-system&quot;&gt;&lt;a href=&quot;#Lab8-file-system&quot; class=&quot;headerlink&quot; title=&quot;Lab8 file system&quot;&gt;&lt;/a&gt;Lab8 file system&lt;/h3&gt;&lt;h4 id=&quot;Large-fil</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab7</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab7%20Lock/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab7%20Lock/</id>
    <published>2022-01-30T09:02:37.076Z</published>
    <updated>2022-01-30T09:04:05.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lab7-Lock"><a href="#Lab7-Lock" class="headerlink" title="Lab7 Lock"></a>Lab7 Lock</h3><h4 id="Memory-allocator"><a href="#Memory-allocator" class="headerlink" title="Memory allocator"></a>Memory allocator</h4><p>This section is to make <code>kalloc</code> and <code>kfree</code> parallelly performed. The main idea is the free-list is shared among all CPUs so all CPUs need to serialize the allocation that we could improve this process by maintaining multiple <code>freelist</code> on different CPU.</p><p>Threads need to steal freepage from other CPU’s if its freelist is null. Actually we could let process steal more pages to reduces the frequency of starve for freelist. But I just do the lazy programing and make process steal one page per time.</p><p>If you add lock properly, this lab won’t be a big problem.</p><h4 id="Buffer-cache"><a href="#Buffer-cache" class="headerlink" title="Buffer cache"></a>Buffer cache</h4><p>Before starting the lab, xv6 book 8.2 to 8.3 section is definitely worthy reading. Namely, buffer cache is a layer between <code>disk</code> and <code>logging</code>  and its exposed API is <code>bwrite()</code> and <code>bread()</code>.  Because not like <code>kalloc</code> after allocation the page is in charge of single process,  bcache’s buffer will be shared among all CPU and we can’t split them.</p><p>So we should use finer-grain lock to reduce the frequency of contention. According to the suggestion in the lab website, we could use a hash table to mapping <code>&lt;dev, blockno&gt;</code> to <code>buf</code>. </p><p>The new <code>struct bcache</code> should like following:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">buf</span>[<span class="title">NBUF</span>];</span></span><br><span class="line">  <span class="comment">// Linked list of all buffers, through prev/next.</span></span><br><span class="line">  <span class="comment">// Sorted by how recently the buffer was used.</span></span><br><span class="line">  <span class="comment">// head.next is most recent, head.prev is least.</span></span><br><span class="line">  <span class="comment">//struct buf head;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">buf</span> <span class="title">bucket</span>[<span class="title">NBUCK</span>];</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">hashlock</span>[<span class="title">NBUCK</span>];</span></span><br><span class="line">&#125; bcache;</span><br></pre></td></tr></table></figure><p>We need to modify two main functions, <code>bget</code> and <code>brelse</code> to acquire more parallelism .</p><p>There are two tricky point to write the correct code.</p><h4 id="Ver1"><a href="#Ver1" class="headerlink" title="Ver1"></a>Ver1</h4><p>Firstly, give a naive scheme:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value := get_hash(dev, blockno);</span><br><span class="line">acquire(hash_table[value]&#x27;s lock);</span><br><span class="line">if no cache found</span><br><span class="line">acquire other hashtable&#x27;s lock</span><br><span class="line">iterate other hash_table to grap idol buffer</span><br></pre></td></tr></table></figure><p>If we acquired lock in the line2 and want to do iteration in line 4-5, it may cause deadlock. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Assume block b1 hashs to 2, b2 hashs to 5</span><br><span class="line">They all not be cached</span><br><span class="line">----------------------------------------</span><br><span class="line">CPU1                  CPU2</span><br><span class="line">----------------------------------------</span><br><span class="line">bget(dev, b1)         bget(dev,b2)</span><br><span class="line">    |                     |</span><br><span class="line">    V                     V</span><br><span class="line">Acquire 2&#x27;s lock      Acquire 5&#x27;s lock</span><br><span class="line">    |                     |</span><br><span class="line">    V                     V</span><br><span class="line">iterate all buckets    iterate all buckets</span><br><span class="line">    |                     |</span><br><span class="line">    V                     V</span><br><span class="line">  ......                </span><br><span class="line">    |                trying to acquire bucket2&#x27;s lock</span><br><span class="line">    |                     |</span><br><span class="line">    V                     V</span><br><span class="line">                    held by CPU1, wait...</span><br><span class="line">trying to acquire bucket5&#x27;s lock</span><br><span class="line">    |</span><br><span class="line">    V</span><br><span class="line">held by CPU2, wait.,.</span><br><span class="line"></span><br><span class="line">!Dead lock!</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>To solve this problem,  recall 4 conditions of deadlock:</p><ul><li>Mutual exclusion</li><li>Hold and wait</li><li>No preemption</li><li>Circular wait</li></ul><p>We can’t solve this deadlock by destroying <code>mutual exclusion</code>, <code>no preemption</code> and <code>circular wait</code> . Here gives an example of <code>circular wait</code>, because we have to iterate through all buckets to find an empty buffer, we can’t give a perfect order of visiting to avoid deadlock.</p><h4 id="Ver2"><a href="#Ver2" class="headerlink" title="Ver2"></a>Ver2</h4><p><strong>So the only option is before acquiring other bucket’s lock, release current lock first.</strong></p><p>But it comes with new problem, the window between the release and acquire is unsafe. It will cause two different threads seek for the same <code>&lt;dev, blockno&gt;</code> in two different empty buffer which violates rules. So we still have to lock.</p><p>Given the following pseudo-code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value := <span class="built_in">get_hash</span>(dev, blockno);</span><br><span class="line"><span class="built_in">acquire</span>(hash_table[value]<span class="string">&#x27;s lock);</span></span><br><span class="line"><span class="string">if no cache found</span></span><br><span class="line"><span class="string">    release(hash_table[value]&#x27;</span>s lock)</span><br><span class="line">    <span class="comment">//dangerous window</span></span><br><span class="line">    <span class="built_in">acquire</span>(bcache<span class="number">&#x27;</span>s lock)<span class="comment">// Note the sequence of release and acuquire</span></span><br><span class="line">acquire other hashtable<span class="number">&#x27;</span>s lock</span><br><span class="line">iterate other hash_table to grap idol buffer</span><br></pre></td></tr></table></figure><p>Note we should release() then acquire whole<code> bcache&#39;s lock</code>. If not may cause deadlock, for the similar reason that maybe exits one scenario that one process holds <code>hash_table[value].lock</code> and waits for <code>bcache.lock</code> and another process holds <code>bcache.lock</code> and waits for <code>hashtable[value].lock</code> in the later iteration.</p><h4 id="Ver3"><a href="#Ver3" class="headerlink" title="Ver3"></a>Ver3</h4><p>The window between release() and acquire() still have race condition, for the same reason and consequence mentioned in previous version. But since we lock the whole <code>critical area</code> from line. 7,  no two threads will in line7-8 simultaneously,  so we just need to check the <code>hash_table[value]</code> if a block is used at the beginning of acquire <code>bcache&#39;s lock</code> to keep synchronized.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">value := get_hash(dev, blockno);</span><br><span class="line">acquire(hash_table[value]<span class="string">&#x27;s lock);</span></span><br><span class="line"><span class="string">if no cache found</span></span><br><span class="line"><span class="string">    release(hash_table[value]&#x27;</span>s lock)</span><br><span class="line">    <span class="comment">//dangerous window</span></span><br><span class="line">    acquire(bcache<span class="number">&#x27;</span>s lock)<span class="comment">// Note the sequence of release and acuquire</span></span><br><span class="line">    <span class="comment">//Check another round        </span></span><br><span class="line">    check <span class="keyword">if</span> cache found</span><br><span class="line">acquire other hashtable<span class="number">&#x27;</span>s lock</span><br><span class="line">iterate other hash_table to grap idol buffer</span><br></pre></td></tr></table></figure><h4 id="Some-hint"><a href="#Some-hint" class="headerlink" title="Some hint"></a>Some hint</h4><ul><li>In multithreading programming,  we could start with a coarse grain lock then reduce granularity step by step to meet the performance requirement.</li><li>Once we want to hold two lock at one time, think carefully about ordering. (If somewhere exists a opposite acquiring sequence)</li><li>Do transaction without lock, and before submitting we check the data consistency. If have a conflict, then we need handle this situation – Our design used this scheme which called Optimistic locking.</li></ul><p>![image-20220102155708798](Lab7 Lock/lab7-1.png)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lab7-Lock&quot;&gt;&lt;a href=&quot;#Lab7-Lock&quot; class=&quot;headerlink&quot; title=&quot;Lab7 Lock&quot;&gt;&lt;/a&gt;Lab7 Lock&lt;/h3&gt;&lt;h4 id=&quot;Memory-allocator&quot;&gt;&lt;a href=&quot;#Memory-al</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab6</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab6%20COW/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab6%20COW/</id>
    <published>2022-01-30T09:02:37.012Z</published>
    <updated>2022-01-30T09:03:41.941Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab6-COW"><a href="#Lab6-COW" class="headerlink" title="Lab6 COW"></a>Lab6 COW</h2><h3 id="Copy-on-write-on-xv6"><a href="#Copy-on-write-on-xv6" class="headerlink" title="Copy-on-write on xv6"></a>Copy-on-write on xv6</h3><p>In this lab, we need to implement COW on xv6. The idea of the lab is quite straight forward but there are some subtle details<br>needs to be treated carefully.</p><p>Main idea of the lab, is to lazily allocate the physical page to child process. This lab takes almost 15h to debug (what fk), so I will give a detailed description of how I code and hope to give a rather clear idea.</p><ul><li>Firstly, define some utils functions to manipulate <code>refrence count table</code><ul><li>int get_ref(uint64 pa) // return reference count </li><li>int dec_ref(uint64 pa) // decrease reference count</li><li>int safy_inc_ref(uint64 pa)  // do increment with lock</li><li>uint64 split_COW(uint64 pa) // return a new page according to the origin physical page</li></ul></li><li>Define a reference counting table, because physical page used for allocation starts from <code>KERNBASE</code>(not so accurate) to <code>PHYSTOP</code>.<ul><li>so declear a array with <code>((PHYSTOP - KERNBASE) / PGSIZE)</code> elements.</li></ul></li><li>The reference counting scheme:<ul><li>Decrease reference count in <code>kfree()</code>, once counting number &lt;= 0 (may have negative number because in kinit() kernel will kfree() all pages first)</li><li>Set reference count = 1 in <code>kalloc()</code></li><li>In the fork()::uvmcopy(), we should do reference increase</li><li>When actually split the COW-page, decrease reference of origin page and alloc a new page.</li></ul></li></ul><p>Once we decide the scheme, we could modify the uvmcopy() to let it map the new_pagetable to old pa.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">uvmcopy</span><span class="params">(<span class="keyword">pagetable_t</span> old, <span class="keyword">pagetable_t</span> <span class="keyword">new</span>, uint64 sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte;</span><br><span class="line">  uint64 pa, i;</span><br><span class="line">  uint flags;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; sz; i += PGSIZE)&#123;</span><br><span class="line">    <span class="keyword">if</span>((pte = walk(old, i, <span class="number">0</span>)) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: pte should exist&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>((*pte &amp; PTE_V) == <span class="number">0</span>)</span><br><span class="line">      panic(<span class="string">&quot;uvmcopy: page not present&quot;</span>);</span><br><span class="line">    *pte = ((*pte) | PTE_COW) &amp; (~PTE_W);<span class="comment">//modify the flags, add COW bit and remove W bit</span></span><br><span class="line">    pa = PTE2PA(*pte);</span><br><span class="line">    flags = PTE_FLAGS(*pte);</span><br><span class="line">    <span class="comment">//if((mem = kalloc()) == 0)</span></span><br><span class="line">      <span class="comment">//goto err;</span></span><br><span class="line">    <span class="comment">//memmove(mem, (char*)pa, PGSIZE);</span></span><br><span class="line">    <span class="keyword">if</span>(mappages(<span class="keyword">new</span>, i, PGSIZE, pa, flags) != <span class="number">0</span>)&#123;<span class="comment">//map old pa to new</span></span><br><span class="line">      <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    safe_inc_ref(pa);<span class="comment">//safely increase reference count</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err:</span><br><span class="line">  uvmunmap(<span class="keyword">new</span>, <span class="number">0</span>, i / PGSIZE, <span class="number">1</span>);</span><br><span class="line">  panic(<span class="string">&quot;uvmcopy goes wrong&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>In the trap.c:usertrap(), we should handle the page fault like previous lazy allocation lab. So I just skip this part.<br>Note the check condition should be:<br><code>va &lt; p-&gt;sz &amp;&amp; ((pte = walk(pagetable, va, 0)) != 0) &amp;&amp; (*pte &amp; PTE_COW) &amp;&amp; (*pte &amp; PTE_V)</code></p><p>Then we do the COW split </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_COW</span><span class="params">(<span class="keyword">pagetable_t</span> pagetable, uint64 va)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pte_t</span> *pte = walk(pagetable, va, <span class="number">0</span>);</span><br><span class="line">  uint64 pa = PTE2PA(*pte);</span><br><span class="line">  <span class="keyword">int</span> flags = (PTE_FLAGS(*pte) | PTE_W) &amp; (~PTE_COW);</span><br><span class="line">  uint64 newpage = cow_split(pa);<span class="comment">//get new allocate page, maybe the origin page</span></span><br><span class="line">  <span class="keyword">if</span>(newpage == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//if out of memory</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//unmap the origin physical page</span></span><br><span class="line">  uvmunmap(pagetable, PGROUNDDOWN(va), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//map the new page with COW remoed and W set</span></span><br><span class="line">  <span class="keyword">if</span>(mappages(pagetable, va, <span class="number">1</span>, newpage, flags) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    panic(<span class="string">&quot;do_cow(): mappages&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note we do the reference reduce in <code>cow_split()</code> and the new page’s reference is set to 1 in <code>kfree()</code></p><p>Finally let’s check the <code>cow_split()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint64</span></span><br><span class="line"><span class="function"><span class="title">cow_split</span><span class="params">(uint64 pa)</span></span>&#123;</span><br><span class="line">  acquire(&amp;reflock);</span><br><span class="line">  <span class="keyword">if</span>(get_ref(pa) &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//If the page just have 1 reference, just return the origin page</span></span><br><span class="line">    release(&amp;reflock);</span><br><span class="line">    <span class="keyword">return</span> pa;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  uint64 <span class="keyword">new</span> = (uint64)kalloc();</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span> == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//Out of memory</span></span><br><span class="line">    release(&amp;reflock);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  memmove((<span class="keyword">void</span>*)<span class="keyword">new</span>, (<span class="keyword">const</span> <span class="keyword">void</span>*)pa, PGSIZE);</span><br><span class="line">  dec_ref(pa); <span class="comment">// reduce origin page refer</span></span><br><span class="line">  release(&amp;reflock);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Just add some glue functions like <code>safe_inc_ref</code>, <code>dec_ref</code>… don’t forget to modify <code>kfree() and kalloc()</code>. Then we are done!<br>![](Lab6 COW/lab6-pic1.png)</p><h4 id="Some-hints"><a href="#Some-hints" class="headerlink" title="Some hints"></a>Some hints</h4><ul><li>Do get pa by <code>PTE2PA</code> macro and not use <code>addrwalk()</code> because it may return 0 if PTE_U not set.</li><li>Use panic to decide some condition shouldn’t happen</li><li>Add locks to reference table, maybe you could try smaller granularity like give each index a lock…</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab6-COW&quot;&gt;&lt;a href=&quot;#Lab6-COW&quot; class=&quot;headerlink&quot; title=&quot;Lab6 COW&quot;&gt;&lt;/a&gt;Lab6 COW&lt;/h2&gt;&lt;h3 id=&quot;Copy-on-write-on-xv6&quot;&gt;&lt;a href=&quot;#Copy-on-w</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab5</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab5%20Lazy%20Allocation/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab5%20Lazy%20Allocation/</id>
    <published>2022-01-30T09:02:37.010Z</published>
    <updated>2022-01-30T09:03:47.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab-5-Lazy-Allocation"><a href="#Lab-5-Lazy-Allocation" class="headerlink" title="Lab 5 Lazy Allocation"></a>Lab 5 Lazy Allocation</h2><p>In this lab, we gonna implement <code>lazy allocation</code> which means delay the true memory allocation till we actually needs it.</p><h3 id="lazy-sbrk"><a href="#lazy-sbrk" class="headerlink" title="lazy sbrk()"></a>lazy sbrk()</h3><p>To start with, we should modify the sbrk() from eager allocation to lazy one.<br>But we should note that the parameter <code>n</code> can be arbitary number, either <code>+ or -</code> so once the number is positve do the lazy allocation, but if the number is negative, we should do the deallocation immediately.</p><h3 id="Lazy-Allocation"><a href="#Lazy-Allocation" class="headerlink" title="Lazy Allocation"></a>Lazy Allocation</h3><p>The time to truely allocate a page, is when kernel receives a <code>No.13 or 15</code> exception, which tells the kernel a non-PTE_V page is being accessed. If the page is lazy allocated but not been truely allocated yet, we should do the allocation and return to the same instruction in the user mode.</p><p>We should check the boundary case, that if  </p><ul><li>va $\in$ [0, p-&gt;sz) (Exclusively contain! <strong>Important</strong>)</li><li>va $\notin$ guard page range  </li></ul><p>Then the virtual address is valid to allocate a new physical page for it. In this part, we could refer to the implementation of <code>uvmalloc</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">allocate_page</span><span class="params">(uint64 va)</span></span>&#123;</span><br><span class="line">  <span class="keyword">pagetable_t</span> pagetable = <span class="built_in">myproc</span>()-&gt;pagetable;</span><br><span class="line">  va = <span class="built_in">PGROUNDDOWN</span>(va);</span><br><span class="line">  <span class="keyword">void</span>* mem = <span class="built_in">kalloc</span>();</span><br><span class="line">  <span class="keyword">if</span>(mem == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), <span class="built_in">myproc</span>()-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Out of memory!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">myproc</span>()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">memset</span>(mem, <span class="number">0</span>, PGSIZE);</span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">mappages</span>(pagetable, va, PGSIZE, (uint64)mem, PTE_W|PTE_R|PTE_U) != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;usertrap(): scause %p pid=%d\n&quot;</span>, <span class="built_in">r_scause</span>(), <span class="built_in">myproc</span>()-&gt;pid);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Can&#x27;t allocate the page table\n&quot;</span>);</span><br><span class="line">    <span class="built_in">kfree</span>(mem);</span><br><span class="line">    <span class="built_in">uvmdealloc</span>(pagetable, <span class="built_in">PGROUNDUP</span>(va), <span class="built_in">PGROUNDDOWN</span>(va));</span><br><span class="line">    <span class="built_in">myproc</span>()-&gt;killed = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that in the original implementation of xv6, we do the eager allocation, which means whenever we visit a virtual address, the physical page is mapped. So there are many <code>panic</code> check in the <code>uvmunmap, walk, uvmcopy...</code> should be canceled, because now many ptes are <code>lazy</code> allocated but not been mapped yet. So just leave to <code>usertrap()</code> to decide whether page should be accessed.</p><p>Last, in the <code>sbrkarg</code> test, it tests the copyin and copyout functions.<br>Because in the kernel mode, kernel simulates the dereference process by <code>walkaddr</code>, it won’t cause a exception. So we should manually modify the function and add a allocation to it.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va0 = PGROUNDDOWN(dstva);</span><br><span class="line"><span class="keyword">if</span>(check_valid(va0) &amp;&amp; ((pte = walk(pagetable, va0, <span class="number">0</span>)) == <span class="number">0</span> || (*pte &amp; PTE_V) == <span class="number">0</span>))&#123;</span><br><span class="line">    allocate_page(va0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Some-hints"><a href="#Some-hints" class="headerlink" title="Some hints"></a>Some hints</h4><ul><li>When encounter a bug, check the backtrace in the gdb.</li><li>The way to decide whether a <code>va</code> is in the guard page, I use <code>if(va &lt; PGROUNDDOWN(p-&gt;trapframe-&gt;sp))</code>. <ul><li>I saw some other’s blog says could use <code>r_sp()</code>, but it just return the kernel stack pointer…</li></ul></li><li>Don’t forget to add codes on copyin, copyout and copyinstr.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab-5-Lazy-Allocation&quot;&gt;&lt;a href=&quot;#Lab-5-Lazy-Allocation&quot; class=&quot;headerlink&quot; title=&quot;Lab 5 Lazy Allocation&quot;&gt;&lt;/a&gt;Lab 5 Lazy Allocation&lt;/</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab4</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab4%20Traps/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab4%20Traps/</id>
    <published>2022-01-30T09:02:37.008Z</published>
    <updated>2022-01-30T08:48:51.962Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab4"><a href="#Lab4" class="headerlink" title="Lab4"></a>Lab4</h2><h3 id="Part2-–Backtrace"><a href="#Part2-–Backtrace" class="headerlink" title="Part2 –Backtrace"></a>Part2 –Backtrace</h3><p>backtrace is the method that prints the address of call stack. To implement backtrace, we should know some key points :  </p><ul><li>In RISC-V, stack grows from high to low.</li><li>fp points to the start of a function(highest address), then <code>Return Address</code> (offset by -8), then previous frame pointer address(offset by -16)</li><li>We should print the address of <code>Return Address</code>(means the address of code)</li><li>Stack size are 1 PGSIZE and aligned.  </li></ul><p>So we just need to fetch the frame pointer by the follower assembly code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> uint64</span></span><br><span class="line"><span class="function"><span class="title">r_fp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  uint64 x;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">&quot;mv %0, s0&quot;</span> : <span class="string">&quot;=r&quot;</span> (x) )</span></span>;</span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Then recursively fetch the previous frame pointer, note we should use check the boundary of one page.</p><h3 id="Part3-–-Alarm"><a href="#Part3-–-Alarm" class="headerlink" title="Part3 – Alarm"></a>Part3 – Alarm</h3><p>In this part, the alarm are like a callback function but trigged by timer(Event driven).<br>So <code>sys_sigalarm</code> are the setter of this scheme, first paramter is the <code>count down</code> number and second is the hanlder of callback function. ‘sys_sigreturn’ is the return function that reloads context of origin function(we will see in the lab)<br>Firstly, we should register two functions in <code>/user</code> and make a syscall reference for them, then we go to <code>/kernel</code> to complete these two syscalls. In the <code>sys_sigalarm</code>, we should keep the tick intervals and the function pointer in the <code>struct proc</code> for later call. Then <code>sys_sigreturn</code>, for now it just return 0 is ok.  </p><p>Note that in the <code>/kernel/trap.c:usertrap()</code>, it handles the all exceptions (syscall, timer interupt…).  Once it is called by an interupt of timer, we should increase the tick number in the <code>struct proc</code> and once <code>ticks == interval</code>, go to handler.  </p><p>By modifing the address of <code>pc</code>, we could jump to the handler. But the way jump back to the origin code should be considered carefully – The lab hints provide us a process to return, which is the <code>sys_sigreturn</code>.  We should reload all the origin(as many as possible to keep the context safy) in it then jump back to origin place(by <code>pc</code> register) </p><h4 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h4><ul><li>p-&gt;trapframe-&gt;epc points to the return address once the process jumps from kernel</li><li>Record as many as possible register in the <code>proc</code> especially <code>pc, sp, ra</code> and so on.</li><li>add backtrace() in <code>panic()</code> so that whenever a panic happens, it will print a backtrace information.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab4&quot;&gt;&lt;a href=&quot;#Lab4&quot; class=&quot;headerlink&quot; title=&quot;Lab4&quot;&gt;&lt;/a&gt;Lab4&lt;/h2&gt;&lt;h3 id=&quot;Part2-–Backtrace&quot;&gt;&lt;a href=&quot;#Part2-–Backtrace&quot; class=&quot;head</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab3</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab3%20Page%20Table/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab3%20Page%20Table/</id>
    <published>2022-01-30T09:02:37.006Z</published>
    <updated>2022-01-30T09:03:27.155Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lab3-pagetable"><a href="#Lab3-pagetable" class="headerlink" title="Lab3 pagetable"></a>Lab3 pagetable</h2><p> In this lab, we will modify the pagetable, and finally be able to dereference pointers in the kernel mode.</p><h3 id="Lab1–Print-page-table"><a href="#Lab1–Print-page-table" class="headerlink" title="Lab1–Print page table"></a>Lab1–Print page table</h3><p> In this lab, it’s much easier than later two lab that we just need to write a DFS recursive function to walk down the 3-level pagetable and print out the path.  </p><p>Check <code>vm.c/freewalk()</code> and dfs the pagetable, note the format of a <code>virtual memory address</code>.<br>![](Lab3 Page Table/lab3-pic1.png)<br>We should notice that different from intel’s pagetable, xv6 store the PPN at high 44-bit.<br>So normally we need the <code>PTE2PA</code> marcos to convert this pagetable content into physic address by shifting over bits.</p><p>Once we get to the lowest-level, we should know that non-leaf nodes have non-setted PTE_W, PTE_R, PTE_X flags (We could use them to detect wheather leaf nodes)</p><h3 id="lab2–Kernel-page-table-per-process"><a href="#lab2–Kernel-page-table-per-process" class="headerlink" title="lab2–Kernel page table per process"></a>lab2–Kernel page table per process</h3><p>This lab is used to prepare us for lab3, which needs make user mode’s pointers deferencable in kernel mode.<br>We should not just keep a pointer of global <code>kernel_pagetable</code> in each process because xv6 support multi-process concurrently run in kernel mode. Thus we need a real copy of kernel page table per process.  </p><p>So we firstly need add a new member variable in the <code>struct proc</code> to record its own kernel page table pointer. Then follow <code>vm.c/kvminit()</code> to initialize the this <code>knpagetbl</code>.  </p><p>Modify the <code>vm.c/kvmmap()</code> function to make it accept one more arguement <code>pagetbl</code>, this function is used to map a va into a pa on one page table.  </p><p>Modify the <code>vm.c/kvmpa()</code> function to make it accept one more argument <code>pagetbl</code>, used to walk down the page table and find the va’s corresponding pa.  </p><p>And we also need mapping kernel stack for each process, note that originally xv6 just keep one kernel page table, so it need to record <code>NPROC</code>‘s kstack mapping to be accessed by <code>NPROC</code>‘s processes. But as we implement the kernel page table for each process, the private kernel page table just need record one kernel stack‘s virtual address points to different physical address. Delete the kernel stack initialization code on <code>proc.c/procinit</code> and do the kstack init on <code>proc.c/allocproc</code>. Note that we could map kstack va on the place because the va is private to each process.  </p><p>Modify the <code>vm.c/schedular()</code> to load the private kernel, (see <code>vm.c/kvminithart</code> ), don’t forget change the satp register back and clean the TLB.</p><p>Free the kernel page table and kstack (Important!), we could imitate <code>vm.c/freewalk()</code> but remember not do free on the real physic pages. And we need to do free kstack first before we free the kernel page table.</p><p>![](Lab3 Page Table/lab3-pic2.png)</p><h3 id="Lab3–Simplify-copyin-copyinstr"><a href="#Lab3–Simplify-copyin-copyinstr" class="headerlink" title="Lab3–Simplify copyin/copyinstr"></a>Lab3–Simplify copyin/copyinstr</h3><p>In the original xv6’s implementation, if we want to dereferen a user’s pointer, the kernel needs simulate the walk down process which should be done by MMU and TLB. (see vm.c/walk()). If we could directly dereference the pointer, this process could be accelarated by the hardware.  </p><p>The main idea is to make every modification on user’s page table reflect on kernel page table. So we firstly need two functions –<br><code>kvmcopy(pagetable_t src , pagetable_t dst, uint64 va, uint64 len)</code><br><code>kvmdealloc(pagetable_t pgtbl, uint64 oldsize, uint64 newsize)</code>  </p><p>Note that in the user mode, virtual memory always grow from 0, (see exec.c/exec() for how va grows), which means if we need to free the memory, we should free from [0, p-&gt;sz].  </p><p>Then for every user page table modification, do mapping to private kernel page table in (<code>exec(), fork(), growproc(), userinit()</code>). Note that in the <code>growproc</code>, the function does not only handle the grow but also shrink of mem, so we need use the <code>kvmdealloc</code> to shrink the kernel page table as well..</p><p><strong>Some Hints</strong> </p><ul><li>After xv6 is booted, the address is at 0xC000000, which is the address of the PLIC register, so user’s page table should not exceed this address. Add a p-&gt;sz check statement in <code>exec()</code>.</li><li>For the same reason, note that CLINT address is under 0xC000000, so do not map this address on the private kernel page table, but we should do so on the global page table.</li><li>Don’t forget free kstack pointer in the <code>freeproc()</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Lab3-pagetable&quot;&gt;&lt;a href=&quot;#Lab3-pagetable&quot; class=&quot;headerlink&quot; title=&quot;Lab3 pagetable&quot;&gt;&lt;/a&gt;Lab3 pagetable&lt;/h2&gt;&lt;p&gt; In this lab, we will </summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab2</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab2%20Syscalls/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab2%20Syscalls/</id>
    <published>2022-01-30T09:02:37.004Z</published>
    <updated>2022-01-30T09:03:11.354Z</updated>
    
    <content type="html"><![CDATA[<h1>System Calls(pending the challenge)</h1><p>In the lab, we will get deeper into OS than the previous one. We are about to implement the ‘bridge’ between user and kernel mode, then implement two specific <code>syscall</code> to be called by user’s program.</p><h2>Lab</h2><p>The two labs are symmetry overall, so I just describe how to do a system call.</p><p>To make our own <code>syscall</code>s,we should know how the syscall works between user &amp; kernel mode.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   user function</span><br><span class="line">     ↓</span><br><span class="line">      wrapped interface</span><br><span class="line">-----------------------------↓(ecall)--------------------------------------</span><br><span class="line">     syscall()</span><br><span class="line">      ↓</span><br><span class="line">kernel sys_(syscall&#x27;s name)</span><br></pre></td></tr></table></figure><p>In this framework, there are some points:</p><ul><li>How to use ecall?<ul><li>We first declare a wrapped function in <code>user/user.h</code>, then implement it in <code>user/usys.S</code> which are assembly code generated by <code>user/usys.pl</code>, the assembly code are used to load the syscall number into <code>a7</code> register.</li></ul></li><li>In kernel mode how to fetch argument?<ul><li>Refer to other functions in <code>kernel/sysproc.c</code>, we can use <code>argint()</code> in <code>kernel/syscall.c</code> to fetch argument from stack</li></ul></li><li>syscall() in <code>kernel/syscall.c</code> , what’s its function?<ul><li>It precedes after ecall, fetches the <code>a7</code> then executes corresponding syscall, then put the return value into <code>a0</code></li></ul></li></ul><h3> Trace</h3><ul><li><p>Remember to put your new syscall number into every part a syscall can involve with, especially don’t forget set the function point entry in <code>syscall.c</code>‘s array.</p></li><li><p>The function uses mask to mark all system call it wants to trace, so each bit on mask is a syscall you should check. Use <code>mask &amp; 1 &lt;&lt; syscallnum </code> to check it.</p></li></ul><p>![Lab2-1](Lab2 Syscalls/Lab2-1.png)</p><h3>Sysinfo</h3><ul><li>The way kernel mode gives back argument to user mode is to call <code>copyout</code> which maps return args’ virtual memory back to physical memory then revises it to target value.</li><li>The collections of free memory and processes is not too hard, we can just iterate the freemem linklist and process array.</li></ul><p>![lab2-2](Lab2 Syscalls/lab2-2.png)</p><h2>Conclusion</h2><p>In this lab, we breakthrough the barrier between u/k mode, the whole detailed system call process is in front of us. But there are still many information we need to get into, <code>mmap, pages management , process management</code>, etc.</p><p>Also, I have not started challenges, because I am about to begin my graduate life in NUS, hopefully I can go back here and finish them someday!</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;System Calls(pending the challenge)&lt;/h1&gt;

&lt;p&gt;In the lab, we will get deeper into OS than the previous one. We are about to implement the</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.S081 Lab1</title>
    <link href="https://zjuytw.github.io/2022/01/30/Lab1%20Unix%20utilities/"/>
    <id>https://zjuytw.github.io/2022/01/30/Lab1%20Unix%20utilities/</id>
    <published>2022-01-30T09:02:37.002Z</published>
    <updated>2022-01-30T09:02:59.979Z</updated>
    
    <content type="html"><![CDATA[<h1>Xv6 and Unix utilities</h1><p>In this lab, we gonna implement many interesting and useful programs like, <code>sleep, pingpong, primes, find, and xargs </code>. There are some points I want to emphasize, though this lab is not so hard.</p><h2>Before Start</h2><p>My experiment environment:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VM: VMware workstation</span><br><span class="line">Linux ubuntu 20.04</span><br></pre></td></tr></table></figure><p> I can not find corresponding software in <code>apt-get</code> when my kernel was at 16.04 or 18.04, so I have to update to 20.04.</p><h2>Lab</h2><p>The structure we should know before programming is that, there are kernel’s and user’s code, when I need to do something on <code>system level</code>, we should call kernel’s function. Gracefully, we have many wrapped interface on users’ functions that we can directly call them. Check them in <code>user/user.h</code></p><h3>sleep</h3><p>Skip</p><h3>    pingpong</h3><p>Note that in pipe[2], pipe[0] is for receiving data and pipe[1] is for writing into.</p><h3>primes</h3><p>The brief of this algorithm is used in the situation that, assume you have a bunch of machines, to find primes given a list of numbers which continuously +1 one after another. And each stage selects one minimum number and it is exactly prime, then verify other numbers do not have the prime as their factor. Then send left numbers into next stage…</p><p>![lab1-1](Lab1 Unix utilities/lab1-1.png)</p><p>Just use recursion to find next stage’s number and send to the child’s process</p><h3>find</h3><p>Refer to <code>user/ls.c</code>, that is a good template.</p><p>What I want to mention is some points of File System</p><p><strong>struct state</strong> is the information a file descriptor refers to, stored in inode and can be fetched by fstat(fd, &amp;st)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define T_DIR 1 // Directory</span><br><span class="line">#define T_FILE 2 // File</span><br><span class="line">#define T_DEVICE 3 // Device</span><br><span class="line">struct stat &#123;</span><br><span class="line">int dev; // File system’s disk device</span><br><span class="line">uint ino; // Inode number</span><br><span class="line">short type; // Type of file</span><br><span class="line">short nlink; // Number of links to file</span><br><span class="line">uint64 size; // Size of file in bytes</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>struct dirent</strong> serves the same a file descriptor’s information, but it mainly provides file’s name</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct dirent</span><br><span class="line">&#123;</span><br><span class="line">    long d_ino; /* inode number */</span><br><span class="line">    off_t d_off; /* offset to this dirent */</span><br><span class="line">    unsigned short d_reclen; /* length of this d_name */</span><br><span class="line">    unsigned char d_type; /* the type of d_name */</span><br><span class="line">    char d_name [NAME_MAX+1]; /* file name (null-terminated) */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>xargs</h2><p>This program helps me to understand xargs a lot, thanks gosh.</p><p>To implement <code>xargs</code>, we need first process <code>stdin</code> because <code>pipe</code> will redirect xargs’s stdin to last program’s stdout. When this done, we can user<code>exec()</code> to execute the command after xargs. Note that when processing stdin, we should read or gets byte by byte and when once encounter ‘\n’, do command.</p><h2>Conclusion</h2><p>This programs helps me to review the usage of them and help me dabble into <code>fork(), exec(), pipe(), and file systems</code></p><p><strong>Note:</strong> when programming for a child process, just use <code>exit</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;Xv6 and Unix utilities&lt;/h1&gt;

&lt;p&gt;In this lab, we gonna implement many interesting and useful programs like, &lt;code&gt;sleep, pingpong, primes</summary>
      
    
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/categories/MIT6-S081/"/>
    
    
    <category term="MIT6.S081" scheme="https://zjuytw.github.io/tags/MIT6-S081/"/>
    
  </entry>
  
</feed>
