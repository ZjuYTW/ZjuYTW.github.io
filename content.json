{"meta":{"title":"Yitao's Blog","subtitle":"","description":"","author":"Wang Yitao","url":"https://ZjuYTW.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-08-09T06:35:31.000Z","updated":"2021-08-09T06:35:31.168Z","comments":true,"path":"categories/index.html","permalink":"https://zjuytw.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2021-08-09T06:12:37.000Z","updated":"2021-08-09T06:12:37.914Z","comments":true,"path":"about/index.html","permalink":"https://zjuytw.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"6.824 Lab2 Conclusion","slug":"6.824-lab2-Conclusion","date":"2021-08-09T08:41:55.508Z","updated":"2021-08-09T09:32:32.334Z","comments":true,"path":"2021/08/09/6.824-lab2-Conclusion/","link":"","permalink":"https://zjuytw.github.io/2021/08/09/6.824-lab2-Conclusion/","excerpt":"","text":"Conclusion After finish 3 parts of Lab, I have implemented a basic raft protocol and it can used to build a K-V storage server. It is fascinating for its understandability and straight idea to build this consensus system. In past 3 parts, I achieved timeout election, append entries, persist and many subtle details to ensure the consistency. My implementation may seem somehow ungraceful especially when I looked the tutorial course 'Go thread and Raft', so I do recommend you to have a look at it before you start your first line of code. storage server 1 storage server 2 storage server 3 K/V service K/V service K/V service Raft Raft Raft In this distributed storage system, clients talk to application layer like K/V service, and application send info to Raft to make distribute replicas. Usually, Raft is a library to be included and easy used Features of Raft Fault Tolerance(using 2n + 1 servers) To avoid split brain, adapt majority voting strategy. The basic logic is if there is a split brain, can not have both partitions own majority server. In Raft’s detail, it means that for new leader, it will assemble at least one server’s vote which from previous majority. We should use one of those previous majority servers as new leader because we should ensure new leader must know what happened before(What term is before). TODO (ALL DONE) I still have some issues need to be addressed, some are performance related and some are many bugs(I don’t know for sure, for me, I’d rather blame these FAIL to too strict test time restriction…) Some time, many 1 out of 10 the test will fail, for the program can not reach agreement. And the reason is easy, timeout election can sometime spend much time to elect a leader. And followings are solutions, from my point. Check if two peer are racing like, one elected in Term x but in Term x + 1, another timeout and start a new round election. For this situation, consider if timer triggers before you reset it Sleep time is a mysterious number I’ve changed them for many times but still have some problem… Currently a fair sleep time is [200, 400] for heartbeat timeout and [50, 100] for election timeout Some threads’ synchronization is implemented heavily so need a more soft way to achieve it(As I will describe afterwards) Some terrible codes need refactoring like substitute all channel by using condition variable and merge analogous code into one function. Especially, primary should become leader as long as it receives majority votes, not until all RPC calls return. Now I have revised my Raft and uses Test Script to test Lab 2 A + B + C 90 times, and result is passed all 90 tests.(I revised my code and continued my test from 10th test, 2 failed is past recorded) This time, I have some new things to write about In fact, we do not need to set extract timer for RequestVote RPC, I once set [50,100]ms range to wait for RPC return, but test result turned out not so well. What we actually need to do is reset timer before start a new election round (So if RPC not return on time, timer will just start next election) Apply interval time need to be considered carefully, because I once set 1000ms to apply new log to state machine, result are worse than 200ms’ When you are encountered with a livelock, check your RequestVote handler. I implemented this function mistakenly and led to the follower with up-to-data log cannot win the election on time. (Specifically, you need to make sure your peer convert to follower whenever it receives a RPC whose term is greater than currentTerm) Check if your output channels are blocked and without receivers. Just uses channel with buffer(Can anybody tell me if go can GC unused channel buffer after both sender and receiver quit?) Oh, I finally did not revise my election part using condition variable, just used channel. ​ Result of a new 100 tests","categories":[{"name":"6.824","slug":"6-824","permalink":"https://zjuytw.github.io/categories/6-824/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"https://zjuytw.github.io/tags/Raft/"},{"name":"Lab Note","slug":"Lab-Note","permalink":"https://zjuytw.github.io/tags/Lab-Note/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-08-09T03:10:31.995Z","updated":"2021-08-09T04:07:37.526Z","comments":true,"path":"2021/08/09/hello-world/","link":"","permalink":"https://zjuytw.github.io/2021/08/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"5841. Find the Longest Valid Obstacle Course at Each Position","slug":"5841. Find the Longest Valid Obstacle Course at Each Position","date":"2021-08-08T17:04:57.677Z","updated":"2021-08-09T08:34:33.477Z","comments":true,"path":"2021/08/09/5841. Find the Longest Valid Obstacle Course at Each Position/","link":"","permalink":"https://zjuytw.github.io/2021/08/09/5841.%20Find%20the%20Longest%20Valid%20Obstacle%20Course%20at%20Each%20Position/","excerpt":"","text":"5841. Find the Longest Valid Obstacle Course at Each Position tag: monotone-stack, greedy, Maximum Increasing Subsequence Description Solution Use monotone-stack to find the longest subsequence end with obstacles[i] Greedily replace the very obstacles[j], j &lt; i that exactly greater than obstacles[i], other elements in the stack just remain 12341 3 5 7 4stack : 1 3 5 7after : 1 3 4 7 Just be careful about the same number should also be inclueded, so just binary search for (obstacle[i] + 1) Code 123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; longestObstacleCourseAtEachPosition(vector&lt;int&gt;&amp; obstacles) &#123; vector&lt;int&gt; dp; vector&lt;int&gt; res; for(int i = 0; i &lt; obstacles.size(); i++)&#123; auto pos = lower_bound(dp.begin(), dp.end(), obstacles[i]+1); if(pos != dp.end())&#123; *pos = obstacles[i]; res.push_back(pos - dp.begin() + 1); &#125;else&#123; dp.push_back(obstacles[i]); res.push_back(dp.size()); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"monotone-stack","slug":"monotone-stack","permalink":"https://zjuytw.github.io/tags/monotone-stack/"},{"name":"greedy","slug":"greedy","permalink":"https://zjuytw.github.io/tags/greedy/"},{"name":"maximum increasing subsequence","slug":"maximum-increasing-subsequence","permalink":"https://zjuytw.github.io/tags/maximum-increasing-subsequence/"}]},{"title":"5840. Minimum Number of Swaps to Make the String Balanced","slug":"5840. Minimum Number of Swaps to Make the String Balanced","date":"2021-08-08T17:00:27.810Z","updated":"2021-08-09T08:34:33.476Z","comments":true,"path":"2021/08/09/5840. Minimum Number of Swaps to Make the String Balanced/","link":"","permalink":"https://zjuytw.github.io/2021/08/09/5840.%20Minimum%20Number%20of%20Swaps%20to%20Make%20the%20String%20Balanced/","excerpt":"","text":"5840. Minimum Number of Swaps to Make the String Balanced tag: stack, greedy Description Solution In each switch, brackets are reduced mostly 2, at least 1. 123//Just swap the first dismatched ] with second dismatched [2 for: ]]] [[[ -&gt; []] [][. 1 for just 1 pair left, switch them then all done Code 12345678910111213141516171819class Solution &#123;public: int minSwaps(string s) &#123; //只要[的右边有对应个数个]即可 stack&lt;int&gt; stk; int res = 0; for(int i = 0; i &lt; s.size(); i++)&#123; if(s[i] == &#x27;[&#x27;)&#123; stk.push(i); &#125;else&#123; if(stk.empty()) res++; else stk.pop(); &#125; &#125; return res - res/2; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"greedy","slug":"greedy","permalink":"https://zjuytw.github.io/tags/greedy/"},{"name":"stack","slug":"stack","permalink":"https://zjuytw.github.io/tags/stack/"}]},{"title":"1792.Maximum Average Pass Ratio","slug":"1792. Maximum Average Pass Ratio","date":"2021-08-08T16:54:36.226Z","updated":"2021-08-09T08:34:33.475Z","comments":true,"path":"2021/08/09/1792. Maximum Average Pass Ratio/","link":"","permalink":"https://zjuytw.github.io/2021/08/09/1792.%20Maximum%20Average%20Pass%20Ratio/","excerpt":"","text":"1792.Maximum Average Pass Ratio tag : Heap, No AC first time Description Solution I feel shamed for I failed to AC it at first time… Use a heap to store the whole develop rate for each class, and find the max dr and use it. O(NlogN) Code 1234567891011121314151617181920212223class Solution &#123;public: double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) &#123; priority_queue&lt;pair&lt;double, int&gt;, vector&lt;pair&lt;double, int&gt;&gt;, less&lt;&gt;&gt; pq; double passrate = 0; for(int i = 0; i &lt; classes.size(); i++)&#123; passrate += 1.0 * classes[i][0] / classes[i][1]; double pr = calPR(classes[i][0]++,classes[i][1]++); pq.emplace(pr, i); &#125; while(extraStudents--)&#123; auto [dr, index] = pq.top(); pq.pop(); passrate += dr; pq.emplace(calPR(classes[index][0]++, classes[index][1]++), index); &#125; return passrate/classes.size(); &#125; double calPR(int p, int t)&#123; return 1.0 * (p + 1) / (t + 1) - 1.0 * p / t; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"},{"name":"Heap","slug":"Heap","permalink":"https://zjuytw.github.io/tags/Heap/"}]},{"title":"1036. Escape a Large Maze","slug":"1036. Escape a Large Maze","date":"2021-08-07T14:12:50.626Z","updated":"2021-08-09T08:34:33.474Z","comments":true,"path":"2021/08/07/1036. Escape a Large Maze/","link":"","permalink":"https://zjuytw.github.io/2021/08/07/1036.%20Escape%20a%20Large%20Maze/","excerpt":"","text":"1036. Escape a Large Maze tag: BFS Description Solution BFS + early quit. Because 1M * 1M is too large for BFS, so we need to find a way to return quickly. blocked.length &lt;= 200 is a good quality we can look into. In a square, the best way to lock an area is laying all blocks 45° as following: 1234567890th _________________________ |O O O O O O O X |O O O O O O X |O O O O O X |O O O O X .O O O X .O O X .O X 200th |X And there are maximally (199 + 1) * 199 /2 = 19900 grids. The exceeding of this number means we can not block one source. So we can return quickly by determine if 19901’s grid has been visited. Code 12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; int dir[5] = &#123;1, 0, -1, 0 , 1&#125;; public: bool isEscapePossible(vector&lt;vector&lt;int&gt;&gt;&amp; blocked, vector&lt;int&gt;&amp; source, vector&lt;int&gt;&amp; target) &#123; set&lt;pair&lt;int,int&gt;&gt; blocks; for(auto block : blocked) blocks.emplace(block[0],block[1]); return bfs(source, blocks, target) &amp;&amp; bfs(target, blocks, source); &#125; bool bfs(vector&lt;int&gt;&amp; source, set&lt;pair&lt;int,int&gt;&gt; blocks, vector&lt;int&gt; &amp;target)&#123; queue&lt;pair&lt;int,int&gt;&gt; q1; q1.emplace(source[0], source[1]); set&lt;pair&lt;int,int&gt;&gt; seen; seen.insert(&#123;source[0], source[1]&#125;); while(!q1.empty())&#123; int size = q1.size(); for(int i = 0; i &lt; size; i ++)&#123; auto [r,c] = q1.front(); q1.pop(); for(int j = 1; j &lt; 5; j++)&#123; int x = r + dir[j-1], y = c + dir[j]; if(x &gt;= 0 &amp;&amp; x &lt; 1E6 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; 1E6)&#123; if(!seen.count(&#123;x,y&#125;) &amp;&amp; !blocks.count(&#123;x,y&#125;))&#123; if(x == target[0] &amp;&amp; y == target[1]) return true; q1.emplace(x,y); seen.insert(&#123;x,y&#125;); &#125; &#125; &#125; &#125; if(seen.size() &gt;= 19901)&#123; cout &lt;&lt; &quot;Oversized&quot; &lt;&lt; endl; return true; &#125; &#125; return false; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://zjuytw.github.io/tags/BFS/"},{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"}]},{"title":"1671. Minimum Number of Removals to Make Mountain Array","slug":"1671. Minimum Number of Removals to Make Mountain Array","date":"2021-08-07T13:13:10.709Z","updated":"2021-08-09T08:34:33.474Z","comments":true,"path":"2021/08/07/1671. Minimum Number of Removals to Make Mountain Array/","link":"","permalink":"https://zjuytw.github.io/2021/08/07/1671.%20Minimum%20Number%20of%20Removals%20to%20Make%20Mountain%20Array/","excerpt":"","text":"1671. Minimum Number of Removals to Make Mountain Array Tag: monotone-stack, DP, No AC first time Description Solution For each index, we can calculate its preceding minimum delete number and its succeeding delete number. Then search for the minimum sum. So how to calculate deleting number? -&gt; calculate longest monotonous sequence A naive way, use DP to calculate: Find the very nums[j] that lower than nums[i], then inherit its by length + 1 1dp[i] = max(dp[j] + 1) for all nums[j] &lt; nums[i] A more efficient way is to maintain a monotone-stack, and greedily replace the very nums[j] that exact greater than nums[i]. Example: 12341 3 5 7 4stack : 1 3 5 7after : 1 3 4 7 ​ So that we can maximally insert number into this monotone-stack which means can get the longest sequence. Code 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: int minimumMountainRemovals(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); vector&lt;pair&lt;int,int&gt;&gt; dp(n,&#123;0,0&#125;); vector&lt;int&gt; stk; for(int i = 0; i &lt; n; i++)&#123; auto pos = lower_bound(stk.begin(), stk.end(), nums[i]); if(pos != stk.end())&#123; *pos = nums[i]; dp[i].first = pos - stk.begin() + 1; &#125;else&#123; stk.push_back(nums[i]); dp[i].first = stk.size(); &#125; &#125; while(!stk.empty())&#123; stk.pop_back(); &#125; for(int i = n-1; i &gt;= 0; i--)&#123; auto pos = lower_bound(stk.begin(), stk.end(), nums[i]); if(pos != stk.end())&#123; *pos = nums[i]; dp[i].second = pos - stk.begin() + 1; &#125;else&#123; stk.push_back(nums[i]); dp[i].second = stk.size(); &#125; &#125; int res = INT_MAX; for(int i = 1; i &lt; n -1; i++)&#123; if(dp[i].first &gt;= 2 &amp;&amp; dp[i].second &gt;= 2)&#123; res = min(res, n - dp[i].first - dp[i].second + 1); &#125; &#125; return res; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"},{"name":"monotone-stack","slug":"monotone-stack","permalink":"https://zjuytw.github.io/tags/monotone-stack/"},{"name":"greedy","slug":"greedy","permalink":"https://zjuytw.github.io/tags/greedy/"},{"name":"DP","slug":"DP","permalink":"https://zjuytw.github.io/tags/DP/"}]},{"title":"457. Circular Array Loop","slug":"457. Circular Array Loop","date":"2021-08-07T04:17:12.129Z","updated":"2021-08-09T08:34:33.476Z","comments":true,"path":"2021/08/07/457. Circular Array Loop/","link":"","permalink":"https://zjuytw.github.io/2021/08/07/457.%20Circular%20Array%20Loop/","excerpt":"","text":"457. Circular Array Loop Tag: Fast-Slow pointers, No AC first time Description Solution To determine a cycle, Fast-Slow pointers is a good way for solving it in linear time and constant space. Some tricky points Determine all positive or all negative Determine length k&gt;1 We can do a product of two nums to judge whether they are same positive or not, and do slow == Next(slow) to judge loop’s length == 1 Code 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: bool circularArrayLoop(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] == 0) continue; int fast = getNext(n, i, nums[i]), slow = i; bool pos = nums[i] &gt; 0, res = true; while(nums[slow] * nums[fast] &gt; 0 &amp;&amp; nums[slow] * nums[getNext(n, fast, nums[fast])] &gt; 0)&#123; if(slow == fast)&#123; if(slow != getNext(n, slow, nums[slow])) return true; break; &#125; slow = getNext(n,slow, nums[slow]); fast = getNext(n, fast, nums[fast]); fast = getNext(n, fast, nums[fast]); &#125; int tmp = i; while(nums[tmp] * nums[getNext(n, tmp, nums[tmp])] &gt; 0)&#123; int step = nums[tmp]; nums[tmp] = 0; tmp = getNext(n, tmp, step); &#125; &#125; return false; &#125; int getNext(int size, int i, int move)&#123; while(i + move &lt; 0) i += size; while(i + move &gt;= size) i -= size; return i + move; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"},{"name":"Fast-Slow pointers","slug":"Fast-Slow-pointers","permalink":"https://zjuytw.github.io/tags/Fast-Slow-pointers/"}]},{"title":"847. Shortest Path Visiting All Nodes","slug":"847. Shortest Path Visiting All Nodes","date":"2021-08-07T02:42:37.295Z","updated":"2021-08-09T08:34:33.477Z","comments":true,"path":"2021/08/07/847. Shortest Path Visiting All Nodes/","link":"","permalink":"https://zjuytw.github.io/2021/08/07/847.%20Shortest%20Path%20Visiting%20All%20Nodes/","excerpt":"","text":"847. Shortest Path Visiting All Nodes Tag: State Compression, BFS, No AC first time Description Solutions We can see from constrains that n&lt;=12, so we can use state compression. Also, the weight of each edge is 1, which reminds us of BFS to search for the lowest distance to reach final state 1&lt;&lt;n - 1 Some tricky points Use tuple to store a three tuple, &#123;node, mask, dist&#125; for the current node, mask and current distance. Use a array or map to store the visited state, states should be distinct by their mask and current node. Code 12345678910111213141516171819202122232425262728293031class Solution &#123;public: int shortestPathLength(vector&lt;vector&lt;int&gt;&gt;&amp; graph) &#123; int n = graph.size(); queue&lt;tuple&lt;int,int,int&gt;&gt; q; //&#123;node, mask, dist&#125; vector&lt;vector&lt;int&gt;&gt; seen(n, vector&lt;int&gt;(1 &lt;&lt; n, 0)); for(int i = 0; i &lt; n; i++)&#123; q.emplace(i, 1 &lt;&lt; i, 0); seen[i][1&lt;&lt;i] = 1; &#125; int ans = 0; while(!q.empty())&#123; auto [u, mask, dist] = q.front(); q.pop(); if(mask == (1 &lt;&lt; n) - 1)&#123; ans = dist; break; &#125; //search adjecent nodes for(auto next : graph[u])&#123; int nxtMask = mask | 1 &lt;&lt; next; if(!seen[next][nxtMask])&#123; q.emplace(next, nxtMask, dist+1); seen[next][nxtMask] = true; &#125; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://zjuytw.github.io/tags/BFS/"},{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"},{"name":"State Compression","slug":"State-Compression","permalink":"https://zjuytw.github.io/tags/State-Compression/"}]}],"categories":[{"name":"6.824","slug":"6-824","permalink":"https://zjuytw.github.io/categories/6-824/"},{"name":"Leetcode","slug":"Leetcode","permalink":"https://zjuytw.github.io/categories/Leetcode/"}],"tags":[{"name":"Raft","slug":"Raft","permalink":"https://zjuytw.github.io/tags/Raft/"},{"name":"Lab Note","slug":"Lab-Note","permalink":"https://zjuytw.github.io/tags/Lab-Note/"},{"name":"monotone-stack","slug":"monotone-stack","permalink":"https://zjuytw.github.io/tags/monotone-stack/"},{"name":"greedy","slug":"greedy","permalink":"https://zjuytw.github.io/tags/greedy/"},{"name":"maximum increasing subsequence","slug":"maximum-increasing-subsequence","permalink":"https://zjuytw.github.io/tags/maximum-increasing-subsequence/"},{"name":"stack","slug":"stack","permalink":"https://zjuytw.github.io/tags/stack/"},{"name":"No AC first time","slug":"No-AC-first-time","permalink":"https://zjuytw.github.io/tags/No-AC-first-time/"},{"name":"Heap","slug":"Heap","permalink":"https://zjuytw.github.io/tags/Heap/"},{"name":"BFS","slug":"BFS","permalink":"https://zjuytw.github.io/tags/BFS/"},{"name":"DP","slug":"DP","permalink":"https://zjuytw.github.io/tags/DP/"},{"name":"Fast-Slow pointers","slug":"Fast-Slow-pointers","permalink":"https://zjuytw.github.io/tags/Fast-Slow-pointers/"},{"name":"State Compression","slug":"State-Compression","permalink":"https://zjuytw.github.io/tags/State-Compression/"}]}